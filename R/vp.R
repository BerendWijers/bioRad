#' Object of class \code{vp}: a vertical profile of birds
#'
#' Class for vertical profiles
#' @param object object of class 'vp'
#' @param x object of class 'vp'
#' @param ... additional arguments affecting the summary produced.
#' @export
#' @rdname summary.vp
#' @method summary vp
#' @details
#' An object of class \code{vp} contains a vertical profile. A vertical profile contains a collection of quantities,
#'  with each quantity having values at different altitude layers above the earth's surface,
#'  typically equally spaced altitudinal layers.
#'
#' Data contained in this class object should be accessed with the \link{get_quantity} function.
#' Information stored under \code{attributes} (see below) can be accessed directly.
#'
#' A \code{vp} object is a list containing
#' \describe{
#'  \item{\strong{\code{radar}}}{the radar identifier}
#'  \item{\strong{\code{datetime}}}{the nominal time of the profile}
#'  \item{\strong{\code{data}}}{the profile data, a list containing:
#'    \describe{
#'        \item{\code{HGHT}}{height above mean sea level [m]. Alt. bin from HGHT to HGHT+interval)}
#'        \item{\code{u}}{speed component west to east [m/s]}
#'        \item{\code{v}}{speed component north to south [m/s]}
#'        \item{\code{w}}{vertical speed (unreliable!) [m/s]}
#'        \item{\code{ff}}{horizontal speed [m/s]}
#'        \item{\code{dd}}{direction [degrees, clockwise from north]}
#'        \item{\code{sd_vvp}}{VVP radial velocity standard deviation [m/s]}
#'        \item{\code{gap}}{Angular data gap detected [T/F]}
#'        \item{\code{dbz}}{Bird reflectivity factor [dBZ]}
#'        \item{\code{eta}}{Bird reflectivity [cm^2/km^3]}
#'        \item{\code{dens}}{Bird density [birds/km^3]}
#'        \item{\code{DBZH}}{Total reflectivity factor (bio+meteo scattering) [dBZ]}
#'        \item{\code{n}}{number of points VVP bird velocity analysis (u,v,w,ff,dd)}
#'        \item{\code{n_all}}{number of points VVP st.dev. estimate (sd_vvp)}
#'        \item{\code{n_dbz}}{number of points bird density estimate (dbz,eta,dens)}
#'        \item{\code{n_dbz_all}}{number of points total reflectivity estimate (DBZH)}
#'    }
#'  }
#'  \item{\strong{\code{attributes}}}{list with the profile's \code{\\what}, \code{\\where} and \code{\\how} attributes}
#' }
summary.vp=function(object, ...) print.vp(object)

#' @rdname summary.vp
#' @export
#' @return for \code{is.vp}: \code{TRUE} if its argument is of class "\code{vp}"
is.vp <- function(x) inherits(x, "vp")

#' @rdname summary.vp
#' @export
#' @return for \code{dim.vp}: dimensions of the profile data
dim.vp <- function(x) {
  stopifnot(inherits(x,"vp"))
  dim(x$data)
}

#' print method for class \code{vp}
#'
#' @param x An object of class \code{vp}, like the result of a call to \link[=summary.vp]{readvp}
#' @keywords internal
#' @export
print.vp=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "vp"))
  cat("               Vertical profile (class vp)\n\n")
  cat("       radar: ",x$radar,"\n")
  cat("      source: ",x$attributes$what$source,"\n")
  cat("nominal time: ",as.character(x$datetime),"\n")
  cat("generated by: ",paste(x$attributes$how$task,x$attributes$how$task_version),"\n")
}


#' Read a time series of vertical profiles (\code{vpts}) from file
#'
#' @param file A text file containing the standard output (stdout) generated by calculate_vp
#' @param radar string containing a radar identifier
#' @param wavelength radar wavelength in cm, or one of 'C' or 'S' for C-band and S-band radar, respectively
#' @export
#' @return an object inhereting from class "\code{vpts}", see \link{vpts} for details
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readvp.table(VPtable,radar="KBGM", wavelength='S')
#' ts
readvp.table=function(file,radar,wavelength='C'){
  if(!file.exists(file)) stop(paste("file",file,"doesn't exist"))
  if(file.size(file)==0) stop(paste("file",file,"is empty"))
  if(missing(radar)) stop("'radar' argument missing. Required to specify a radar identifier")
  if(missing(wavelength)) warning(paste("No 'wavelength' argument provided, assuming radar operates at ",wavelength,"-band",sep=""))
  if(wavelength=='C') wavelength=5.3
  if(wavelength=='S') wavelength=10.6
  if(!is.numeric(wavelength) || length(wavelength)>1) stop("not a valid 'wavelength' argument")
  #header of the data file
  header.names.short=c("Date","Time","HGHT","u","v","w","ff","dd","sd_vvp","gap","dbz","eta","dens","DBZH","n","n_dbz","n_all","n_dbz_all")
  header.names.long=c("Date","Time","HGHT","u","v","w","ff","dd","sd_vvp","head_bl","head_ff","head_dd","head_sd","gap","dbz","eta","dens","DBZH","n","n_dbz","n_all","n_dbz_all")
  #read the data
  data=read.table(file=file, header = F)
  if(ncol(data)==22) colnames(data)=header.names.long else colnames(data)=header.names.short
  # convert Time into a POSIXct date-time
  data$datetime <- as.POSIXct(paste(data$Date, sprintf('%04d', data$Time), sep = ""), format = "%Y%m%d%H%M", tz='UTC')
  data$Date<-NULL
  data$Time<-NULL
  # sort
  data=data[with(data, order(datetime, HGHT)),]
  # remove duplicates
  data=unique(data)
  # split into profiles
  data=split(data,data$datetime)
  names(data)<-NULL
  # verify that profiles can be flattened
  datadim=sapply(1:length(data), function(x) dim(data[[x]]))
  if(length(unique(datadim[1,]))>1){
    mostFrequent=sort(table(datadim[1,]),decreasing=T)[1]
    if(mostFrequent<=1) stop("Profiles are of unequal altitudinal dimensions, unable to merge")
    mostFrequentNBins=as.integer(names(mostFrequent))
    warning(paste("Profiles are of unequal altitudinal dimensions or contain duplicates. Discarding",length(data)-mostFrequent,"of",length(data),"profiles, restricting to",mostFrequentNBins,"altitude bins."))
    data=data[datadim[1,]==mostFrequentNBins]
  }
  # strip the datetime field
  dates=.POSIXct(sapply(1:length(data),function(x) data[[x]]$datetime[1]),tz="UTC")
  data=lapply(data, function(x) { x["datetime"] <- NULL; x })
  # check whether the time series is regular
  difftimes=difftime(dates[-1],dates[-length(dates)],units="secs")
  if(length(unique(difftimes))==1) regular = T else regular = F
  # flatten the profiles
  profile.quantities=names(data[[1]])
  vpsFlat=lapply(profile.quantities, function(quantity) sapply(data,'[[',quantity))
  names(vpsFlat)=profile.quantities
  vpsFlat$HGHT<-NULL
  # prepare output
  heights=data[[1]]$"HGHT"
  interval=unique(heights[-1]-heights[-length(heights)])

  attributes=list(where=data.frame(interval=interval,levels=length(heights)),how=data.frame(wavelength=wavelength))
  output=list(radar=radar,dates=dates,heights=heights,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),timesteps=difftimes,data=vpsFlat,attributes=attributes,regular=regular)
  class(output)="vpts"
  output
}

readOdimProfileData = function(file,group){
  whatgroup=h5readAttributes(file,sprintf("%s/what",group))
  nodata=whatgroup$nodata
  undetect=whatgroup$undetect
  gain=whatgroup$gain
  offset=whatgroup$offset
  data=h5read(file,sprintf("%s/data",group))[1,]
  data=replace(data,data==nodata,NA)
  data=replace(data,data==undetect,NaN)
  offset+gain*data
}

quantityName = function(file,group){
  whatgroup=h5readAttributes(file,paste(group,"/what",sep=""))
  whatgroup$quantity
}

#' Convert a vertical profile (\code{vp}) to a Data Frame
#'
#' Converts a vertical profile to a Data Frame,
#' and optionally adds information on sunrise/sunset, day/night and derived quantities
#' like migration traffic rates.
#' @param x object of class vp
#' @param row.names \code{NULL} or a character vector giving the row names for the data frame. Missing values are not allowed.
#' @param optional If \code{FALSE} then the names of the variables in the data frame are checked to ensure that they are syntactically valid variable names and are not duplicated.
#' @param quantities an optional character vector with the names of the quantities to include as columns in the data frame
#' @param elev sun elevation in degrees, see \link{suntime}.
#' @param lat radar latitude in decimal degrees. When set, overrides the latitude stored in \code{x} in \link{suntime} calculations
#' @param lon radar longitude in decimal degrees. When set, overrides the longitude stored in \code{x} in \link{suntime} calculations
#' @param suntime logical. When TRUE, adds sunrise/sunset and day/night information to each row
#' @param geo logical. When TRUE, adds latitude, longitude and antenna height of the radar to each row
#' @param ... additional arguments to be passed to or from methods.
#' @return an object of class data.frame
#' @export
#' @details
#' Note that only the 'dens' quantity is thresholded by the radial velocity standard deviation \link{sd_vvp}.
#' Note that this is different from the default \link{plot.vp}, \link{plot.vpts} and \link{get_quantity.vp} functions, where
#' quantities "eta","dbz","ff","u","v","w","dd" are all thresholded by \link{sd_vvp}
#' @examples
#' # load an example vertical profile time series object
#' data(VP)
#' # convert the object to a data.frame
#' df=as.data.frame(VP)
#' # do not compute sunrise/sunset information
#' df=as.data.frame(VP,suntime=FALSE)
#' # override the latitude/longitude information stored in the object
#' # when calculating sunrise / sunset
#' df=as.data.frame(VP,suntime=TRUE,lat=50,lon=4)
as.data.frame.vp = function(x, row.names = NULL, optional = FALSE, quantities=names(x$data),suntime=TRUE,geo=TRUE, elev = -0.268, lat=NULL, lon=NULL, ...){
  stopifnot(inherits(x,"vp"))
  if(!is.null(row.names)){
    if(is.character(row.names) & length(row.names)==length(x$dates)*length(x$heights)) rownames(output)=row.names
    else stop(paste("'row.names' is not a character vector of length",length(x$dates)*length(x$heights)))
  }
  if(is.null(lat)) lat = x$attributes$where$lat
  if(is.null(lon)) lon = x$attributes$where$lon
  missing=which(!(quantities %in% names(x$data)))
  if(length(missing)>0) stop(paste(paste(quantities[missing],collapse=" "),"not an available quantity, select one or more of",paste(names(x$data),collapse=",")))
  # coerce data to a data frame
  output=as.data.frame(x$data,optional=optional,...)
  # add height and datetime as a column
  output=cbind(datetime=x$datetime,height=output$HGHT, output)
  output$HGHT<-NULL
  # add radar name
  output=cbind(radar=x$radar,output,stringsAsFactors=FALSE)
  # add location information
  if(geo){
    output$lat=lat
    output$lon=lon
    output$height_antenna=x$attributes$where$height
  }
  # override the lat,lon attributes in case of user-provided values
  x$attributes$where$lat=lat
  x$attributes$where$lon=lon
  # add day
  if(suntime){
    dayQ=!check_night(x,elev=elev)
    dayQ=c(t(replicate(nrow(x),dayQ)))
    output=cbind(output,day=dayQ)
    sunrise=suntime(x$datetime,lat=lat,lon=lon,rise=T)
    sunset=suntime(x$datetime,lat=lat,lon=lon,rise=F)
    output$sunrise=as.POSIXct(c(t(replicate(nrow(x),sunrise))),origin="1970-1-1",tz='UTC')
    output$sunset=as.POSIXct(c(t(replicate(nrow(x),sunset))),origin="1970-1-1",tz='UTC')
  }
  output
}
