#' Analyze and visualize biological signals in weather radar data
#'
#' @references
#' \itemize{
#'  \item Bird migration flight altitudes studied by a network of operational weather radars, Dokter et al., J. R. Soc. Interace 8 (54), pp. 30--43, 2011. DOI \href{http://dx.doi.org/10.1098/rsif.2010.0116}{10.1098/rsif.2010.0116}
#' }
#'
#'
#' @import h5
"_PACKAGE"
#> [1] "_PACKAGE"

#VP=readVP("~/git/bioRad/inst/extdata/profile.h5")
#save(VP,file="~/git/bioRad/data/VP.RData")
#' Example object of class \code{VP} as generated by \code{\link{readVP}}
"VP"

library(h5)
docker=F

#' Checks that Docker is running
#'
#' Checks that \href{https://www.docker.com/}{Docker} daemon is running correctly on the local system
#' @param verbose logical (not NA) which indicates whether print test results to screen
#' @export
checkDocker = function(verbose=T){
  system("docker rm -f hello-world",ignore.stderr=T,ignore.stdout=T)
  result=system("docker run --name hello-world hello-world",ignore.stderr=!verbose,ignore.stdout=!verbose)
  unlockBinding("docker", environment(checkDocker))
  environment(checkDocker)$docker=(result==0)
  lockBinding("docker", environment(checkDocker))
  if(!verbose) return(result)
}

setLoadActions(function(ns)
  cat("Loading package", sQuote(getNamespaceName(ns)), "...\n"),
  function(ns) if((checkDocker(verbose=F)!=0)){
    cat("Warning: no running Docker daemon found\n")
    cat("Warning:",getNamespaceName(ns),"functionality requiring Docker has been disabled\n\n")
    cat("To enable Docker functionality, start Docker and run 'checkDocker()' in R")
    unlockBinding("docker", environment(checkDocker))
    assign("docker", F, envir = ns)
  }
  else{
    cat("Docker daemon running, Docker functionality enabled.\n")
  }
)

readOdimProfileData = function(file,group){
  whatgroup = file[sprintf("%s/what",group)]
  nodata=h5attr(whatgroup,"nodata")
  undetect=h5attr(whatgroup,"undetect")
  gain=h5attr(whatgroup,"gain")
  offset=h5attr(whatgroup,"offset")
  dset=file[sprintf("%s/data",group)]
  data=readDataSet(dset)
  data=replace(data,data==nodata,NA)
  data=replace(data,data==undetect,NaN)
  h5close(dset)
  h5close(whatgroup)
  offset+gain*data
}

quantityName = function(file,group){
  whatgroup=file[paste(group,"/what",sep="")]
  quantity=h5attr(whatgroup,"quantity")
  h5close(whatgroup)
  quantity
}

#' Read a vertical profile (VP) from file
#'
#' @param filename A string containing the path to a vertical profile generated by \link[bioRad]{vol2bird}
#' @export
#' @return an object of class \code{VP}, which is a list containing
#' \describe{
#'  \item{\strong{\code{radar}}}{the radar identifier}
#'  \item{\strong{\code{datetime}}}{the nominal time of the profile [UTC]}
#'  \item{\strong{\code{data}}}{the profile data, a list containing:
#'    \describe{
#'        \item{\code{HGHT}}{height above mean sea level [m]. Alt. bin from HGHT to HGHT+interval)}
#'        \item{\code{u}}{speed component west to east [m/s]}
#'        \item{\code{v}}{speed component north to south [m/s]}
#'        \item{\code{w}}{vertical speed (unreliable!) [m/s]}
#'        \item{\code{ff}}{horizontal speed [m/s]}
#'        \item{\code{dd}}{direction [degrees, clockwise from north]}
#'        \item{\code{sd_vvp}}{VVP radial velocity standard deviation direction [m/s]}
#'        \item{\code{gap}}{Angular data gap detected [T/F]}
#'        \item{\code{dbz}}{Bird reflectivity factor [dBZ]}
#'        \item{\code{eta}}{Bird reflectivity [cm^2/km^3]}
#'        \item{\code{dens}}{Bird density [birds/km^3]}
#'        \item{\code{DBZH}}{Total reflectivity factor (bio+meteo scattering) [dBZ]}
#'        \item{\code{n}}{number of points VVP bird velocity analysis}
#'        \item{\code{n_dbz}}{number of points bird density estimate}
#'        \item{\code{n_all}}{number of points VVP velocity Stdev analysis}
#'        \item{\code{n_all_dbz}}{number of points total reflectivity estimate}
#'    }
#'  }
#'  \item{\strong{\code{attributes}}}{list with the profile's \code{\\what}, \code{\\where} and \code{\\how} attributes}
#' }
#' @examples
#' # locate example profile file:
#' prof <- system.file("extdata", "profile.h5", package="bioRad")
#' # print the local path of the profile file:
#' prof
#' # load the file:
#' readVP(prof)
#'
readVP = function(filename){
  if(!VPFileQ(filename)) return(NULL)
  file = h5file(filename,mode="r")
  #check input argument
  if(!inherits(file,"H5File")) stop("'file' should be a HDF5 file")
  if(!existsGroup(file,"dataset1")){
    h5close(file)
    stop("HDF5 file does not contain a /dataset1 group")
  }

  #extract quantities
  dataset1=file["dataset1"]
  groups=list.groups(dataset1,recursive=F)
  quantities=sapply(groups,function(x) quantityName(file,x))
  profile=as.data.frame(lapply(groups,function(x) readOdimProfileData(file,x)))
  names(profile)=quantities

  #extract attributes
  howgroup=file["how"]
  whatgroup=file["what"]
  wheregroup=file["where"]
  attribNames.how=list.attributes(howgroup)
  attribNames.what=list.attributes(whatgroup)
  attribNames.where=list.attributes(wheregroup)
  attribs.how=as.data.frame(lapply(attribNames.how,function(x) h5attr(howgroup,x)),stringsAsFactors=F)
  attribs.what=as.data.frame(lapply(attribNames.what,function(x) h5attr(whatgroup,x)),stringsAsFactors=F)
  attribs.where=as.data.frame(lapply(attribNames.where,function(x) h5attr(wheregroup,x)),stringsAsFactors=F)
  names(attribs.how)=attribNames.how
  names(attribs.what)=attribNames.what
  names(attribs.where)=attribNames.where

  #convert some useful metadata
  datetime=as.POSIXct(paste(attribs.what$date, attribs.what$time), format = "%Y%m%d %H%M%S", tz='UTC')
  sources=strsplit(attribs.what$source,",")[[1]]
  radar=gsub("RAD:","",sources[which(grepl("RAD:",sources))])

  #prepare output
  output=list(radar=radar,datetime=datetime,data=profile,attributes=list(how=attribs.how,what=attribs.what,where=attribs.where))
  class(output) = "VP"
  h5close(dataset1)
  h5close(howgroup)
  h5close(wheregroup)
  h5close(whatgroup)
  h5close(file)
  output
}

#' Check whether file is a vertical profile
#'
#' Checker whether a file is a vertical profile that can be read with package \pkg{bioRad}
#'
#' @param filename A string containing a filename
#' @export
#' @return TRUE when \code{filename} is a vertical profile, otherwise FALSE
#' @examples
#' VPFileQ("/not/a/valid/VP/file.h5")   #> FALSE
#'
VPFileQ = function(filename){
  if(!is.h5file(filename)){
    warning(paste(filename,"is not a HDF5 file"))
    return(FALSE)
  }
  file = h5file(filename,mode="r")
  output = T
  if(!existsGroup(file,"dataset1")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /dataset1 group"))
  }
  if(!existsGroup(file,"what")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /what group"))
  }
  else{
    if("object" %in% list.attributes(file["what"])){
      object=h5attr(file["what"],"object")
      if(object != "VP"){
        warning(paste("VP object expected in HDF5 file ",filename,". Found ",object," object instead.",sep=""))
        output=F
      }
    }
    else{
      warning("'object' attribute not found in /what group")
      output=F
    }
  }
  if(!existsGroup(file,"how")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /how group"))
  }
  if(!existsGroup(file,"where")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /where group"))
  }
  h5close(file)
  return(output)
}


#' print method for class \code{VP}
#'
#' @param x An object of class \code{VP}, like the result of a call to \link[bioRad]{readVP}
#' @keywords internal
#' @export
print.VP=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VP"))
  cat("               Vertical profile (class VP)\n\n")
  cat("       radar: ",x$radar,"\n")
  cat("      source: ",x$attributes$what$source,"\n")
  cat("nominal time: ",as.character(x$datetime),"\n")
  cat("generated by: ",paste(x$attributes$how$task,x$attributes$how$task_version),"\n")
}

#' Plot a vertical profile
#'
#' @param x a VP class object
#' @param xlab a title for the x axis
#' @param ylab a title for the y axis
#' @param line.col Color of the plotted curve
#' @param line.lwd Line width of the plotted curve
#' @param main an overall title for the plot
#' @param ... Additional arguments to be passed to the low level \link[graphics]{plot} plotting function
#' @export
#' @examples
#' data(VP)
#' plot(VP)
#' plot(VP,line.col='blue')
plot.VP=function(x, xlab="density [#/km^3]",ylab="height [km]",main="Vertical profile",line.col='red',line.lwd=1,...){
  plot(x$data$dens,x$data$HGHT/1000,xlab=xlab,ylab=ylab,main=main,...)
  points(x$data$dens,x$data$HGHT/1000, col=line.col,lwd=line.lwd,type="l")
}

#' Read a list of vertical profiles from multiple files
#'
#' @param files A string vector containing the filenames of vertical profiles in ODIM HDF5 format generated by \link[bioRad]{vol2bird}
#' @export
#' @return an object of class \code{VPList}, which is a list containing
#' \describe{
#'  \item{\code{VPList}}{vertical profiles, a list of \code{VP} objects, see \link[bioRad]{readVP} for a description}
#'  \item{\code{radars}}{the radars represented in the list}
#'  \item{\code{daterange}}{the minimum and maximum nominal time of the profiles in the list}
#'  \item{\code{dates}}{the nominal times of the profiles}
#' }
#' @examples
#' \dontrun{readVP(c("my/path/profile1.h5","my/path/profile2.h5", ...))}
#'
readVP.list=function(files){
  VPs=lapply(files,readVP)
  # remove nulls
  VPs <- VPs[!sapply(VPs, is.null)]
  do.call(c.VP,VPs)
}


#' concatenate \code{VP} objects into a \code{VPList} object
#' @param ... objects of class \code{VP}
#' @export
#' @keywords internal
#' @return an object of class \code{VPList}, see \link[bioRad]{readVP.list} for details
c.VP = function(...){
  VPs=list(...)
  VPtest=sapply(VPs,function(x) is(x,"VP"))
  if(FALSE %in% VPtest) {
    warning("non-VP objects found, returning an unconcatenated list...")
    return(VPs)
  }
  # sort by datetime
  VPs[order(sapply(VPs,'[[',"datetime"))]
  # extract radar identifiers
  radars=unique(sapply(VPs,'[[',"radar"))
  if(length(radars)>1) warning("Vertical profiles are not from a single radar")
  # extract date-times
  dates=.POSIXct(do.call("c",lapply(VPs,'[[',"datetime")),tz="UTC")
  output=list(VPList=VPs,radar=radars,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),dates=dates)
  class(output)="VPList"
  output
}

#' print method for class \code{VPList}
#'
#' @param x An object of class \code{VPList}, usually a result of a call to \link[bioRad]{readVP.list}
#' @keywords internal
#' @export
print.VPList=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VPList"))
  cat("                   List of vertical profiles (class VPList)\n\n")
  cat("          radars: ",x$radar,"\n")
  cat("      # profiles: ",length(x$VPList),"\n")
  cat("time range (UTC): ",as.character(x$daterange[1]),"-",as.character(x$daterange[2]),"\n")
}

#' Convert \code{VPList} to a single radar time series
#'
#' @param x An object of class \code{VPList}, usually a result of a call to \link[bioRad]{readVP.list}
#' @param radar string containing the radar identifier to generate time series for. Only required when \code{VPList} object contains multiple radars
#' @export
#' @return an object of class \code{VPTimeSeries}, which is a list containing
#' \describe{
#'  \item{\code{radar}}{string containing the radar identifier}
#'  \item{\code{dates}}{the \code{N} nominal times of the profiles}
#'  \item{\code{heights}}{the \code{M} heights of the layers in the profile}
#'  \item{\code{daterange}}{the minimum and maximum nominal time of the profiles in the list}
#'  \item{\code{timesteps}}{time differences between the profiles. Element \code{i} gives the time difference between profile \code{i} and \code{i+1}}
#'  \item{\code{data}}{list of \code{N} by \code{M} matrices containing the vertical profiles for each quantity.
#'                     For a description of available quantities, see the \code{data} element of the \code{VP} class in \link[bioRad]{readVP}}
#'  \item{\code{attributes}}{profile attributes, copied from the first profile contained in \code{x}}
#'  \item{\code{regular}}{logical indicating whether the time series is regular or not}
#' }
#' @examples
#' \dontrun{readVP(c("my/path/profile1.h5","my/path/profile2.h5", ...))}
#'
VPTimeSeries=function(x,radar=NA){
  stopifnot(inherits(x, "VPList"))
  if(length(x$radar)>1 && is.na(radar)) stop("vertical profile list of multiple radars, select one with 'radar' argument")
  if(!is.na(radar) && !(radar %in% x$radar)) stop(paste("no profiles found for radar",radar))
  if(is.na(radar)) radar=x$radar
  radars=sapply(x$VPList,'[[',"radar")
  index=which(radars==radar)
  VPs=x$VPList[index]
  dates=.POSIXct(do.call("c",lapply(VPs,'[[',"datetime")),tz="UTC")
  difftimes=difftime(dates[-1],dates[-length(dates)],units="mins")
  profile.quantities=names(VPs[[1]]$data)

  where.attributes=sapply(lapply(VPs,'[[',"attributes"),'[[',"where")
  if(length(unique(unlist(where.attributes["interval",])))>1) stop("vertical profiles have different altitude bin size")
  if(length(unique(unlist(where.attributes["levels",])))>1) stop("vertical profiles have different number of altitude bins")
  if(length(unique(unlist(where.attributes["maxheight",])))>1) stop("vertical profiles have different maxheight")
  if(length(unique(unlist(where.attributes["minheight",])))>1) stop("vertical profiles have different minheight")
  VPsFlat=lapply(profile.quantities, function(quantity) sapply(lapply(VPs,'[[',"data"),'[[',quantity))
  names(VPsFlat)=profile.quantities
  if(length(unique(difftimes))==1) regular = T else regular = F
  VPsFlat$HGHT<-NULL
  output=list(radar=radar,dates=dates,heights=VPs[[1]]$data$HGHT,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),timesteps=difftimes,data=VPsFlat,attributes=VPs[[1]]$attributes,regular=regular)
  class(output)="VPTimeSeries"
  output
}

#' print method for class \code{VPTimeSeries}
#'
#' @param x An object of class \code{VPTimeSeries}, usually a result of a call to \link[bioRad]{VPTimeSeries}
#' @keywords internal
#' @export
print.VPTimeSeries=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VPTimeSeries"))
  cat("                  ",if(x$regular) "Regular" else "Irregular","time series of vertical profiles (class VPTimeSeries)\n\n")
  cat("           radar: ",x$radar,"\n")
  cat("      # profiles: ",length(x$dates),"\n")
  cat("time range (UTC): ",as.character(x$daterange[1]),"-",as.character(x$daterange[2]),"\n")
  if(x$regular) cat("   time step (s): ",min(x$timesteps),"\n")
  else cat("   time step (s): ","min:",min(x$timesteps),"    max: ",max(x$timesteps),"\n")
}

#' Calculate a vertical profile of birds (VPB)
#'
#' Calculates a vertical profile of birds (VPB) from a polar volume
#'
#' @param volume.in A radar file containing a radar polar volume, either in
#' \href{http://www.eumetnet.eu/sites/default/files/OPERA2014_O4_ODIM_H5-v2.2.pdf}{ODIM}
#' format, which is the implementation of the OPERA data information model in \href{https://support.hdfgroup.org/HDF5/}{HDF5} format,
#' or a format supported by the \href{http://trmm-fc.gsfc.nasa.gov/trmm_gv/software/rsl/}{RSL library})
#' @param profile.out character string. Filename for the vertical profile to be generated in ODIM HDF5 format (optional)
#' @param volume.out character string. Filename for the polar volume to be generated in ODIM HDF5 format (optional, e.g. for converting RSL formats to ODIM)
#' @param verbose logical. When TRUE, pipe Docker stdout to R terminal
#' @details Requires a running \href{https://www.docker.com/}{Docker} daemon
#' @export
#' @examples
#' # locate example volume file:
#' volume <- system.file("extdata", "volume.h5", package="bioRad")
#' # copy to a home directory with read/write permissions:
#' file.copy(volume,"~/volume.h5")
#' # load the profile:
#' profile=vol2bird("~/volume.h5")
#' # plot the profile
#' plot(profile)
#' # clean up:
#' file.remove("~/volume.h5")
vol2bird =  function(volume.in, profile.out="", volume.out="",verbose=F){
  if(!docker) stop("Requires a running Docker daemon.\nTo enable vol2bird, start your local Docker daemon, and run 'checkDocker()' in R")
  if(!file.exists(volume.in)) stop("No such file or directory")
  if(!length(verbose)==1 || !is.logical(verbose)) stop("verbose argument should be one of TRUE or FALSE")
  if(profile.out!="" && !file.exists(dirname(profile.out))) stop(paste("output directory",dirname(profile.out),"not found"))
  filedir=dirname(normalizePath(volume.in))
  profile.tmp=tempfile(tmpdir=filedir)
  if(file.access(filedir,mode=2)<0) stop(paste("vol2bird requires write permission in",filedir))
  system("docker rm -f vol2bird", ignore.stderr=T,ignore.stdout=T)
  result=system(paste("docker run -v ",filedir,":/data -d --name vol2bird adokter/vol2bird sleep infinity",sep=""),ignore.stdout=T)
  if(result!=0) stop(paste("failed to mount",filedir,"... Go to 'Docker -> preferences -> File Sharing' and add this directory (or its root directory) as a bind mounted directory"))
  system(paste("docker exec vol2bird bash -c 'cd data && vol2bird ",basename(volume.in),basename(profile.tmp),volume.out,"'"),ignore.stdout=!verbose)
  system("docker rm -f vol2bird", ignore.stderr=T,ignore.stdout=T)
  output=readVP(profile.tmp)
  if(profile.out=="") file.remove(profile.tmp)
  else file.rename(profile.tmp,profile.out)
  output
}

#' Read vertical profiles from vol2bird stdout
#'
#' @param file A text file containing the standard output (stdout) generated by vol2bird
#' @param radar string containing a radar identifier
#' @export
#' @return an object inhereting from class "\code{VPTimeSeries}", see \link[bioRad]{VPTimeSeries} for details
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM")
#' ts
readVP.table=function(file,radar){
  if(!file.exists(file)) stop(paste("file",file,"doesn't exist"))
  if(missing(radar)) stop("'radar' argument missing. Required to specify a radar identifier")
  #header of the data file
  header.names=c("Date","Time","HGHT","u","v","w","ff","dd","sd_vvp","gap","dbz","eta","dens","DBZH","n","n_dbz","n_all","n_dbz_all")
  #read the data
  data=read.table(file=file, header = F, col.names=header.names)
  # convert Time into a POSIXct date-time
  data$datetime <- as.POSIXct(paste(data$Date, sprintf('%04d', data$Time), sep = ""), format = "%Y%m%d%H%M", tz='UTC')
  data$Date<-NULL
  data$Time<-NULL
  # sort
  data=data[with(data, order(datetime, HGHT)),]
  # split into profiles
  data=split(data,data$datetime)
  # strip the datetime field
  dates=.POSIXct(sapply(1:length(data),function(x) data[[x]]$datetime[1]),tz="UTC")
  data=lapply(data, function(x) { x["datetime"] <- NULL; x })
  # check whether the time series is regular
  difftimes=difftime(dates[-1],dates[-length(dates)],units="mins")
  if(length(unique(difftimes))==1) regular = T else regular = F
  # verify that profiles can be flattened
  if(length(unique(lapply(1:length(data), function(x) dim(data[[x]]))))>1){
    stop("Profiles are of unequal dimensions, unable to flatten ...")
  }
  # flatten the profiles
  profile.quantities=names(data[[1]])
  VPsFlat=lapply(profile.quantities, function(quantity) sapply(data,'[[',quantity))
  names(VPsFlat)=profile.quantities
  VPsFlat$HGHT<-NULL
  # prepare output
  heights=data[[1]]$"HGHT"
  interval=unique(heights[-1]-heights[-length(heights)])
  attributes=list(where=data.frame(interval=interval,levels=length(heights)))
  output=list(radar=radar,dates=dates,heights=heights,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),timesteps=difftimes,data=VPsFlat,attributes=attributes,regular=regular)
  class(output)="VPTimeSeries"
  output
}

#' Regularize a time series
#'
#' Projects objects of class \code{VPTimeSeries} on a regular time grid
#' @param ts an object inhereting from class \code{VPTimeSeries}, see \link[bioRad]{VPTimeSeries} for details
#' @param units optional units of \code{interval}, one of 'secs', 'mins', 'hours','days', 'weeks'. Defaults to 'mins'.
#' @param fill logical. Whether to fill empty timesteps with the values of the closest neighbouring profile
#' @export
#' @return an object of class \code{VPTimeSeries} with regular time steps
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM")
#' # regularize the time series on a 5 minute interval grid
#' tsRegular=regularize(ts, interval=5)
regularize=function(ts,interval="auto",units="mins",fill=F){
  stopifnot(inherits(ts, "VPTimeSeries"))
  if (!(units %in% c("secs", "mins", "hours","days", "weeks"))) stop("invalid 'units' argument. Should be one of c('secs', 'mins', 'hours','days', 'weeks')")
  if (!is.numeric(interval) || length(units)>1) stop("invalid or missing 'interval' argument. Should be a numeric value")
  if (!is.logical(fill) || length(fill)>1) stop("fill argument should be a logical value")
  dt=as.difftime(interval,units=units)
  grid=seq(from=ts$daterange[1],to=ts$daterange[2],by=dt)
  index=sapply(grid,function(x) which.min(abs(ts$dates - x)))
  quantity.names=names(ts$data)
  ts$data=lapply(1:length(ts$data),function(x) ts$data[[x]][,index])
  if(!fill){
    index2=which(abs(ts$dates[index] - grid)>as.double(dt,units="secs"))
    ts$data=lapply(1:length(ts$data),function(x) {
        tmp=ts$data[[x]]
        tmp[,index2]<-NA
        tmp
      }
    )
  }
  names(ts$data)=quantity.names
  ts$dates=grid
  ts$timesteps=rep(as.double(dt,units="secs"),length(grid)-1)
  ts$regular=T
  return(ts)
}

#' Calculate migration traffic rate (MTR)
#'
#' Calculate migration traffic rate (MTR) for an altitude layer, defined as the
#' number of targets crossing a 1 km line perpendicular to the migratory movement per hour
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @export
#' @param alt.min minimum altitude in m
#' @param alt.max maximum altitude in m
#' @return an atomic vector with MTRs in individuals/km/h
MTR <- function (x, ...) UseMethod("MTR", x)

#' @describeIn MTR MTR of a vertical profile
#' @export
#' @examples
#' # MTR for a vertical profile:
#' MTR(VP)
#'
#' plot(ts$dates,MTR(ts),type='l')
MTR.VP = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VP"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  interval=x$attributes$where$interval
  index=which(x$data$HGHT>alt.min & x$data$HGHT<alt.max)
  mtr=sum(x$data$dens[index] * x$data$ff[index] * interval/1000,na.rm=T)
  return(mtr)
}

#' @describeIn MTR MTR of a list of vertical profiles
#' @export
#' @examples
#' # MTRs for a list of vertical profiles
#' MTR(c(VP,VP))
MTR.VPList = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VPList"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  mtr=sapply(x$VPList,MTR.VP,alt.min=alt.min,alt.max=alt.max)
  return(mtr)
}

#' @describeIn MTR MTR of a list of vertical profiles
#' @export
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM")
#' # print migration traffic rates:
#' MTR(ts)
#' # plot migration traffic rates for the full air column:
#' plot(ts$dates,MTR(ts),type='l',xlab="time [UTC]",ylab="MTR [birds/km/h]")
#' #' plot migration traffic rates for altitudes > 1 km above sea level
#' plot(ts$dates,MTR(ts,alt.min=1000),type='l',xlab="time [UTC]",ylab="MTR [birds/km/h]")
MTR.VPTimeSeries = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VPTimeSeries"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  interval=x$attributes$where$interval
  index=which(x$heights>alt.min & x$heights<alt.max)
  mtr=colSums(x$data$ff[index,]*x$data$dens[index,],na.rm=T)*interval/1000
  return(mtr)
}

#' Class VP
#'
#' Class for vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VP=function(x) print.VP(x)

#' @rdname summary.VP
#' @export
#' @keywords internal
#' @return for \code{is.VP}: \code{TRUE} if its argument is of class "\code{VP}"
is.VP <- function(x) inherits(x, "VP")

#' @rdname summary.VP
#' @export
#' @keywords internal
#' @return for \code{dim.VP}: dimensions of the profile data
dim.VP <- function(x) {
  stopifnot(inherits(x,"VP"))
  dim(x$data)
}

#' Class VPList
#'
#' Class for list of vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VPList=function(x) print.VPList(x)

#' @rdname summary.VPList
#' @export
#' @keywords internal
#' @return for \code{is.VPList}: \code{TRUE} if its argument is of class "\code{VPList}"
is.VPList <- function(x) inherits(x, "VPList")

#' @rdname summary.VPList
#' @export
#' @keywords internal
`[.VPList` <- function(x,i) {
  stopifnot(inherits(x,"VPList"))
  x$VPList[[i]]
}

#' @rdname summary.VPList
#' @export
#' @keywords internal
`[[.VPList` <- function(x,i) {
  stopifnot(inherits(x,"VPList"))
  x$VPList[[i]]
}

#' Class VPTimeSeries
#'
#' Class for single-site time series of vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VPTimeSeries=function(x) print.VPTimeSeries(x)

#' @rdname summary.VPTimeSeries
#' @export
#' @keywords internal
#' @return for \code{is.VPTimeSeries}: \code{TRUE} if its argument is of class "\code{VPTimeSeries}"
is.VPTimeSeries <- function(x) inherits(x, "VPTimeSeries")

#' @rdname summary.VPTimeSeries
#' @export
#' @keywords internal
#' @return for \code{dim.VPTimeSeries}: dimensions of the time series
dim.VPTimeSeries <- function(x) {
  stopifnot(inherits(x,"VPTimeSeries"))
  data.dim=dim(x$data[[1]])
  c(data.dim,length(x$data))
}
