#' Analyze and visualize biological signals in weather radar data
#'
#' @references
#' \itemize{
#'  \item Bird migration flight altitudes studied by a network of operational weather radars, Dokter et al., J. R. Soc. Interace 8 (54), pp. 30--43, 2011. DOI \href{http://dx.doi.org/10.1098/rsif.2010.0116}{10.1098/rsif.2010.0116}
#' }
#'
#'
#' @import rhdf5
#' @import fields

"_PACKAGE"
#> [1] "_PACKAGE"


#VP=readVP("~/git/bioRad/inst/extdata/profile.h5")
#save(VP,file="~/git/bioRad/data/VP.RData")
#' Example object of class \code{VP} as generated by \code{\link{readVP}}
"VP"

# locate example file:
# VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
# load time series:
# VPTS=readVP.table(VPtable,radar="KBGM", wavelength='S')
# save(VPTS,file="~/git/bioRad/data/VPTS.RData")
#' Example object of class \code{VPTimeSeries}
"VPTS"

docker=F
mounted=F
mount="~/"

#' Checks that Docker is running
#'
#' Checks that \href{https://www.docker.com/}{Docker} daemon is running correctly on the local system
#' @param verbose logical which indicates whether to print test results to R console
#' @export
checkDocker = function(verbose=T){
  system("docker rm -f hello-world",ignore.stderr=T,ignore.stdout=T)
  result=system("docker run --name hello-world hello-world",ignore.stderr=!verbose,ignore.stdout=!verbose)
  unlockBinding("docker", environment(checkDocker))
  unlockBinding("mounted", environment(checkDocker))
  environment(checkDocker)$docker=(result==0)
  environment(checkDocker)$mounted=F
  lockBinding("docker", environment(checkDocker))
  lockBinding("mounted", environment(checkDocker))
  if(!verbose) return(result)
}

startContainer = function(mount="~/"){
  parent.env=environment(startContainer)
  # if docker not running, cannot start container
  if(!parent.env$docker) return(1)
  # if container already running at this mount point, nothing to be done:
  if(parent.env$mounted & parent.env$mount==mount) return(0)
  # remove any existing vol2bird containers
  system("docker rm -f vol2bird", ignore.stderr=T,ignore.stdout=T)
  # fire up the container:
  result=system(paste("docker run -v ",normalizePath(mount),":/data -d --name vol2bird adokter/vol2bird sleep infinity",sep=""),ignore.stdout=T)
  if(result!=0) warning(paste("failed to mount",mount,"... Go to 'Docker -> preferences -> File Sharing' and add this directory (or its root directory) as a bind mounted directory"))
  else{
    unlockBinding("mounted",parent.env)
    unlockBinding("mount",parent.env)
    parent.env$mounted=(result==0)
    parent.env$mount=mount
    lockBinding("mounted", parent.env)
    lockBinding("mount", parent.env)
  }
  return(result)
}

setLoadActions(function(ns)
  cat("Loading package", sQuote(getNamespaceName(ns)), "...\n"),
  function(ns) if((checkDocker(verbose=F)!=0)){
    cat("Warning: no running Docker daemon found\n")
    cat("Warning:",getNamespaceName(ns),"functionality requiring Docker has been disabled\n\n")
    cat("To enable Docker functionality, start Docker and run 'checkDocker()' in R")
    unlockBinding("docker", environment(checkDocker))
    assign("docker", F, envir = ns)
  }
  else{
    cat("Docker daemon running, Docker functionality enabled.\n")
  }
)

readOdimProfileData = function(file,group){
  whatgroup=h5readAttributes(file,sprintf("%s/what",group))
  nodata=whatgroup$nodata
  undetect=whatgroup$undetect
  gain=whatgroup$gain
  offset=whatgroup$offset
  data=h5read(file,sprintf("%s/data",group))[1,]
  data=replace(data,data==nodata,NA)
  data=replace(data,data==undetect,NaN)
  offset+gain*data
}

quantityName = function(file,group){
  whatgroup=h5readAttributes(file,paste(group,"/what",sep=""))
  whatgroup$quantity
}

#' Read a vertical profile (VP) from file
#'
#' @param filename A string containing the path to a vertical profile generated by \link[bioRad]{vol2bird}
#' @export
#' @return an object of class \code{VP}, which is a list containing
#' \describe{
#'  \item{\strong{\code{radar}}}{the radar identifier}
#'  \item{\strong{\code{datetime}}}{the nominal time of the profile [UTC]}
#'  \item{\strong{\code{data}}}{the profile data, a list containing:
#'    \describe{
#'        \item{\code{HGHT}}{height above mean sea level [m]. Alt. bin from HGHT to HGHT+interval)}
#'        \item{\code{u}}{speed component west to east [m/s]}
#'        \item{\code{v}}{speed component north to south [m/s]}
#'        \item{\code{w}}{vertical speed (unreliable!) [m/s]}
#'        \item{\code{ff}}{horizontal speed [m/s]}
#'        \item{\code{dd}}{direction [degrees, clockwise from north]}
#'        \item{\code{sd_vvp}}{VVP radial velocity standard deviation [m/s]}
#'        \item{\code{gap}}{Angular data gap detected [T/F]}
#'        \item{\code{dbz}}{Bird reflectivity factor [dBZ]}
#'        \item{\code{eta}}{Bird reflectivity [cm^2/km^3]}
#'        \item{\code{dens}}{Bird density [birds/km^3]}
#'        \item{\code{DBZH}}{Total reflectivity factor (bio+meteo scattering) [dBZ]}
#'        \item{\code{n}}{number of points VVP bird velocity analysis (u,v,w,ff,dd)}
#'        \item{\code{n_dbz}}{number of points bird density estimate (dbz,eta,dens)}
#'        \item{\code{n_all}}{number of points VVP st.dev. estimate (sd_vvp)}
#'        \item{\code{n_all_dbz}}{number of points total reflectivity estimate (DBZH)}
#'    }
#'  }
#'  \item{\strong{\code{attributes}}}{list with the profile's \code{\\what}, \code{\\where} and \code{\\how} attributes}
#' }
#' @examples
#' # locate example profile file:
#' prof <- system.file("extdata", "profile.h5", package="bioRad")
#' # print the local path of the profile file:
#' prof
#' # load the file:
#' readVP(prof)
#'
readVP = function(filename){
  if(!is.VPfile(filename)) return(NULL)
  #check input argument
  groups=h5ls(filename,recursive=F)$name
  if(!("dataset1" %in% groups)){
    stop("HDF5 file does not contain a /dataset1 group")
  }
  #extract quantities
  groups=h5ls(filename)
  groups=groups[which(groups$name=="data"),]$group
  quantities=sapply(groups,function(x) quantityName(filename,x))
  profile=as.data.frame(lapply(groups,function(x) readOdimProfileData(filename,x)))
  names(profile)=quantities

  #extract attributes
  attribs.how=h5readAttributes(filename,"how")
  attribs.what=h5readAttributes(filename,"what")
  attribs.where=h5readAttributes(filename,"where")

  #convert some useful metadata
  datetime=as.POSIXct(paste(attribs.what$date, attribs.what$time), format = "%Y%m%d %H%M%S", tz='UTC')
  sources=strsplit(attribs.what$source,",")[[1]]
  radar=gsub("RAD:","",sources[which(grepl("RAD:",sources))])

  #prepare output
  output=list(radar=radar,datetime=datetime,data=profile,attributes=list(how=attribs.how,what=attribs.what,where=attribs.where))
  class(output) = "VP"
  output
}

#' Read a polar volume (PVOL) from file
#'
#' @param filename A string containing the path to a vertical profile generated by \link[bioRad]{vol2bird}
#' @param sort logical. When \code{TRUE} sort scans ascending by elevation
#' @param params atomic vector of character strings, containing the names of scan parameters to read
#' @export
#' @return an object of class \code{PVOL}, which is a list containing polar scans, i.e. objects of class \code{SCAN}
#' \describe{
#'  \item{\strong{\code{radar}}}{the radar identifier}
#'  \item{\strong{\code{datetime}}}{the nominal time of the volume [UTC]}
#'  \item{\strong{\code{scans}}}{a list with scan objects}
#'  \item{\strong{\code{attributes}}}{list with the volume's \code{\\what}, \code{\\where} and \code{\\how} attributes}
#' }
#' @examples
#' # locate example profile file:
#' pvol <- system.file("extdata", "volume.h5", package="bioRad")
#' # print the local path of the profile file:
#' pvol
#' # load the file:
#' read.pvol(prof)
#'
read.pvol = function(filename,param=c("DBZH","VRADH","RHOHV","ZDR","PHIDP"),sort=T){
  if(!is.PVOLfile(filename)) return(NULL)

  #extract scan groups
  scans=h5ls(pvol,recursive=F)$name
  scans=scans[grep("dataset",scans)]

  #extract attributes
  attribs.how=h5readAttributes(filename,"how")
  attribs.what=h5readAttributes(filename,"what")
  attribs.where=h5readAttributes(filename,"where")

  #convert some useful metadata
  datetime=as.POSIXct(paste(attribs.what$date, attribs.what$time), format = "%Y%m%d %H%M%S", tz='UTC')
  sources=strsplit(attribs.what$source,",")[[1]]
  radar=gsub("RAD:","",sources[which(grepl("RAD:",sources))])

  #read scan groups
  data=lapply(scans,function(x) read.scan(filename,x))
  #order by elevation
  if(sort) data=data[order(sapply(data,elev))]

  #prepare output
  output=list(radar=radar,datetime=datetime,scans=data,attributes=list(how=attribs.how,what=attribs.what,where=attribs.where))
  class(output) = "PVOL"
  elev(output)
  output
}

read.scan=function(filename,scan){
  groups=h5ls(filename)
  groups=groups[groups$group==paste("/",scan,sep=""),]$name
  groups=groups[grep("data",groups)]

  quantities=lapply(groups,function(x) read.quantity(filename,paste(scan,"/",x,sep="")))
  quantityNames=sapply(quantities,'[[',"quantityName")
  quantities=lapply(quantities,'[[',"quantity")
  names(quantities)=quantityNames

  attribs.how=h5readAttributes(filename,paste(scan,"/how",sep=""))
  attribs.what=h5readAttributes(filename,paste(scan,"/what",sep=""))
  attribs.where=h5readAttributes(filename,paste(scan,"/where",sep=""))

  output=list(params=quantities,attributes=list(how=attribs.how,what=attribs.what,where=attribs.where))
  class(output)="SCAN"
  output
}

read.quantity=function(filename,quantity){
  data=h5read(filename,quantity)$data
  attr=h5readAttributes(filename,paste(quantity,"/what",sep=""))
  data=replace(data,data==attr$nodata,NA)
  data=replace(data,data==attr$undetect,NaN)
  data=attr$offset+attr$gain*data
  class(data)=c("PARAM",class(data))
  list(quantityName=attr$quantity,quantity=data)
}

#' Check whether file is a vertical profile
#'
#' Checker whether a file is a vertical profile that can be read with package \pkg{bioRad}
#'
#' @param filename A string containing a filename
#' @export
#' @return TRUE when \code{filename} is a vertical profile, otherwise FALSE
#' @examples
#' is.VPfile("/not/a/valid/VP/file.h5")   #> FALSE
#'
is.VPfile = function(filename){
  type=h5ODIMobject(filename)
  if(is.na(type)) return(FALSE)
  else return(type=="VP")
}

#' Check whether file is a polar volume
#'
#' Checker whether a file is a polar volume that can be read with package \pkg{bioRad}
#'
#' @param filename A string containing a filename
#' @export
#' @return TRUE when \code{filename} is a polar volume in readable format, otherwise FALSE
#' @examples
#' is.PVOLfile("/not/a/valid/PVOL/file.h5")   #> FALSE
#'
is.PVOLfile = function(filename){
  type=h5ODIMobject(filename)
  if(is.na(type)) return(FALSE)
  else return(type=="PVOL")
}

#' Check ODIM HDF5 data class
#'
#' Checks which data class is contained in ODIM HDF5 file
#'
#' @param filename A string containing a filename
#' @export
#' @return character string "\code{PVOL}" for polar volume, "\code{VP}" for vertical profile, otherwise \code{NA}
#' @examples
#' # locate a polar volume file
#' pvol <- system.file("extdata", "volume.h5", package="bioRad")
#' h5ODIMobject(pvol)   #> "PVOL"
#'
h5ODIMobject = function(filename){
  if(!is.ODIMfile(filename)){
    warning(paste(filename,"is not a ODIM HDF5 file"))
    return(NA)
  }
  object=h5readAttributes(filename,"what")$object
  return(object)
}

is.ODIMfile = function(filename){
  if(!H5Fis_hdf5(filename)){
    warning(paste(filename,"is not a HDF5 file"))
    return(FALSE)
  }
  output = T
  groups=h5ls(filename,recursive=F)$name
  if(!("dataset1" %in% groups)){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /dataset1 group"))
  }
  if(!("what" %in% groups)){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /what group"))
  }
  else{
    object=h5readAttributes(filename,"what")$object
    if(is.null(object)){
      warning("'object' attribute not found in /what group")
      output=F
    }
  }
  if(!("how" %in% groups)){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /how group"))
  }
  if(!("where" %in% groups)){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /where group"))
  }
  return(output)
}


#' print method for class \code{VP}
#'
#' @param x An object of class \code{VP}, like the result of a call to \link[bioRad]{readVP}
#' @keywords internal
#' @export
print.VP=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VP"))
  cat("               Vertical profile (class VP)\n\n")
  cat("       radar: ",x$radar,"\n")
  cat("      source: ",x$attributes$what$source,"\n")
  cat("nominal time: ",as.character(x$datetime),"\n")
  cat("generated by: ",paste(x$attributes$how$task,x$attributes$how$task_version),"\n")
}

#' print method for class \code{PVOL}
#'
#' @param x An object of class \code{PVOL}, a polar volume
#' @keywords internal
#' @export
print.PVOL=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "PVOL"))
  cat("               Polar volume (class PVOL)\n\n")
  cat("     # scans: ",length(x$scans),"\n")
  cat("       radar: ",x$radar,"\n")
  cat("      source: ",x$attributes$what$source,"\n")
  cat("nominal time: ",as.character(x$datetime),"\n\n")
}

#' print method for class \code{SCAN}
#'
#' @param x An object of class \code{SCAN}, a polar scan
#' @keywords internal
#' @export
print.SCAN=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "SCAN"))
  cat("                  Polar scan (class SCAN)\n\n")
  cat("     parameters: ",names(x$params),"\n")
  cat("      elevation: ",x$attributes$where$elangle,"\n")
  cat("           dims: ",x$attributes$where$nbins," bins x ",x$attributes$where$nrays," rays\n")
}

#' print method for class \code{PARAM}
#'
#' @param x An object of class \code{PARAM}, a polar scan parameter
#' @keywords internal
#' @export
print.PARAM=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "PARAM"))
  cat("               Polar scan parameter (class PARAM)\n\n")
  cat("  range bins: ",dim(x)[1],"\n")
  cat("        rays: ",dim(x)[2],"\n")
}


#' Plot a vertical profile
#'
#' @param x a VP class object
#' @param xlab a title for the x axis
#' @param ylab a title for the y axis
#' @param line.col Color of the plotted curve
#' @param line.lwd Line width of the plotted curve
#' @param main an overall title for the plot
#' @param ... Additional arguments to be passed to the low level \link[graphics]{plot} plotting function
#' @export
#' @examples
#' data(VP)
#' plot(VP)
#' plot(VP,line.col='blue')
plot.VP=function(x, xlab="density [#/km^3]",ylab="height [km]",main="Vertical profile",line.col='red',line.lwd=1,...){
  stopifnot(inherits(x,"VP"))
  pdat=x$data$dens
  pdat[is.na(pdat)]=0
  plot(pdat,x$data$HGHT/1000,xlab=xlab,ylab=ylab,main=main,...)
  points(pdat,x$data$HGHT/1000, col=line.col,lwd=line.lwd,type="l")
}

#' Read a list of vertical profiles from multiple files
#'
#' @param files A string vector containing the filenames of vertical profiles in ODIM HDF5 format generated by \link[bioRad]{vol2bird}
#' @export
#' @return an object of class \code{VPList}, which is a list \code{VP} objects
#' @examples
#' \dontrun{readVP(c("my/path/profile1.h5","my/path/profile2.h5", ...))}
#'
readVP.list=function(files){
  VPs=lapply(files,readVP)
  # remove nulls
  VPs <- VPs[!sapply(VPs, is.null)]
  do.call(c.VP,VPs)
}


#' concatenate \code{VP} objects into a \code{VPList} object
#' @param ... objects of class \code{VP}
#' @export
#' @keywords internal
#' @return an object of class \code{VPList}, see \link[bioRad]{readVP.list} for details
c.VP = function(...){
  VPs=list(...)
  VPtest=sapply(VPs,function(x) is(x,"VP"))
  if(FALSE %in% VPtest) {
    warning("non-VP objects found, returning a standard list...")
    return(VPs)
  }
  # extract radar identifiers
  radars=unique(sapply(VPs,'[[',"radar"))
  if(length(radars)>1) warning("Vertical profiles are not from a single radar")
  # extract date-times
  dates=.POSIXct(do.call("c",lapply(VPs,'[[',"datetime")),tz="UTC")
  output=list(VPList=VPs,radar=radars,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),dates=dates)
  output=VPs
  class(output)="VPList"
  output
}

#' @rdname summary.VPList
#' @export
#' @keywords internal
`[.VPList` <- function(x,i) {
  stopifnot(inherits(x,"VPList"))
  if(length(i)==1) return(x[[i]])
  output=unclass(x)[i]
  class(output)="VPList"
  return(output)
}

#' print method for class \code{VPList}
#'
#' @param x An object of class \code{VPList}, usually a result of a call to \link[bioRad]{readVP.list}
#' @keywords internal
#' @export
print.VPList=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VPList"))
  # extract radar identifiers
  radar=unique(sapply(x,'[[',"radar"))
  # extract date-times
  dates=.POSIXct(do.call("c",lapply(x,'[[',"datetime")),tz="UTC")
  daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC")
  cat("                   List of vertical profiles (class VPList)\n\n")
  cat("          radars: ",radar,"\n")
  cat("      # profiles: ",length(x),"\n")
  cat("time range (UTC): ",as.character(daterange[1]),"-",as.character(daterange[2]),"\n")
}

#' Convert \code{VPList} to a single radar time series
#'
#' @param x An object of class \code{VPList}, usually a result of a call to \link[bioRad]{readVP.list}
#' @param radar string containing the radar identifier to generate time series for. Only required when \code{VPList} object contains multiple radars
#' @export
#' @return an object of class \code{VPTimeSeries}, which is a list containing
#' \describe{
#'  \item{\code{radar}}{string containing the radar identifier}
#'  \item{\code{dates}}{the \code{N} nominal times of the profiles}
#'  \item{\code{heights}}{the \code{M} heights of the layers in the profile}
#'  \item{\code{daterange}}{the minimum and maximum nominal time of the profiles in the list}
#'  \item{\code{timesteps}}{time differences between the profiles. Element \code{i} gives the time difference between profile \code{i} and \code{i+1}}
#'  \item{\code{data}}{list of \code{N} by \code{M} matrices containing the vertical profiles for each quantity.
#'                     For a description of available quantities, see the \code{data} element of the \code{VP} class in \link[bioRad]{readVP}}
#'  \item{\code{attributes}}{profile attributes, copied from the first profile contained in \code{x}}
#'  \item{\code{regular}}{logical indicating whether the time series is regular or not}
#' }
#' @examples
#' \dontrun{readVP(c("my/path/profile1.h5","my/path/profile2.h5", ...))}
#'
VPTimeSeries=function(x,radar=NA){
  stopifnot(inherits(x, "VPList"))
  # extract radar identifiers
  radars=sapply(x,'[[',"radar")
  uniqueRadars=unique(radars)
  # extract date-times
  dates=.POSIXct(do.call("c",lapply(x,'[[',"datetime")),tz="UTC")
  daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC")
  if(length(uniqueRadars)>1 & is.na(radar)) stop("vertical profile list of multiple radars, select one with 'radar' argument")
  if(!is.na(radar) & !(radar %in% uniqueRadars)) stop(paste("no profiles found for radar",radar))
  if(is.na(radar) & length(uniqueRadars==1)) radar=uniqueRadars
  index=which(radars==radar)
  VPs=x[index]
  # sort by datetime
  VPs=VPs[order(sapply(VPs,'[[',"datetime"))]
  dates=.POSIXct(do.call("c",lapply(VPs,'[[',"datetime")),tz="UTC")
  difftimes=difftime(dates[-1],dates[-length(dates)],units="secs")
  profile.quantities=names(VPs[[1]]$data)

  where.attributes=sapply(lapply(VPs,'[[',"attributes"),'[[',"where")
  if(length(unique(unlist(where.attributes["interval",])))>1) stop("vertical profiles have different altitude bin size")
  if(length(unique(unlist(where.attributes["levels",])))>1) stop("vertical profiles have different number of altitude bins")
  if(length(unique(unlist(where.attributes["maxheight",])))>1) stop("vertical profiles have different maxheight")
  if(length(unique(unlist(where.attributes["minheight",])))>1) stop("vertical profiles have different minheight")
  VPsFlat=lapply(profile.quantities, function(quantity) sapply(lapply(VPs,'[[',"data"),'[[',quantity))
  names(VPsFlat)=profile.quantities
  if(length(unique(difftimes))==1) regular = T else regular = F
  VPsFlat$HGHT<-NULL
  output=list(radar=radar,dates=dates,heights=VPs[[1]]$data$HGHT,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),timesteps=difftimes,data=VPsFlat,attributes=VPs[[1]]$attributes,regular=regular)
  class(output)="VPTimeSeries"
  output
}

#' print method for class \code{VPTimeSeries}
#'
#' @param x An object of class \code{VPTimeSeries}, usually a result of a call to \link[bioRad]{VPTimeSeries}
#' @keywords internal
#' @export
print.VPTimeSeries=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VPTimeSeries"))
  cat("                  ",if(x$regular) "Regular" else "Irregular","time series of vertical profiles (class VPTimeSeries)\n\n")
  cat("           radar: ",x$radar,"\n")
  cat("      # profiles: ",length(x$dates),"\n")
  cat("time range (UTC): ",as.character(x$daterange[1]),"-",as.character(x$daterange[2]),"\n")
  if(x$regular) cat("   time step (s): ",min(x$timesteps),"\n")
  else cat("   time step (s): ","min:",min(x$timesteps),"    max: ",max(x$timesteps),"\n")
}

#' Calculate a vertical profile of birds (VPB)
#'
#' Calculates a vertical profile of birds (VPB) from a polar volume
#'
#' @param vol.in A radar file containing a radar polar volume, either in
#' \href{http://www.eumetnet.eu/sites/default/files/OPERA2014_O4_ODIM_H5-v2.2.pdf}{ODIM}
#' format, which is the implementation of the OPERA data information model in \href{https://support.hdfgroup.org/HDF5/}{HDF5} format,
#' or a format supported by the \href{http://trmm-fc.gsfc.nasa.gov/trmm_gv/software/rsl/}{RSL library})
#' @param vp.out character string. Filename for the vertical profile to be generated in ODIM HDF5 format (optional)
#' @param vol.out character string. Filename for the polar volume to be generated in ODIM HDF5 format (optional, e.g. for converting RSL formats to ODIM)
#' @param verbose logical. When TRUE, pipe Docker stdout to R console
#' @param mount character string with the mount point (a director path) for the Docker container
#' @param sd_vvp numeric. lower threshold in radial velocity standard deviation for an altitude layer containing birds in m/s
#' @param rcs numeric. Radar cross section per bird in cm^2.
#' @param dualpol logical. Whether to use dual-pol mode, in which meteorological echoes are filtered using the correlation coeficient \code{rhohv}
#' @param rhohv numeric. Lower threshold in correlation coefficient used to filter meteorological scattering
#' @param elev.min numeric. Minimum scan elevation in degrees
#' @param elev.max numeric. Maximum scan elevation in degrees
#' @param azim.min numeric. Minimum azimuth in degrees clockwise from north
#' @param azim.max numeric. Maximum azimuth in degrees clockwise from north
#' @param range.min numeric. Minimum range in km
#' @param range.max numeric. Maximum range in km
#' @param nlayer numeric. Number of altitude layers in the profile
#' @param hlayer numeric. Width of altitude layers in metre
#' @param nyquist.min numeric. Minimum Nyquist velocity of scans in m/s
#' @param dealias logical. Whether to dealias scans
#' @param nyquist.dealias numeric. Dealias scans with a Nyquist velocity below this value will be dealiased, scans with a Nyquist velocity above this value will be used as is. NOT IMPLEMENTED YET!
#' @details Requires a running \href{https://www.docker.com/}{Docker} daemon
#'
#' \code{azim.min} and \code{azim.max} only affects reflectivity-derived estimates in the profile (DBZH,eta,dens),
#' not radial-velocity derived estimates (u,v,w,ff,dd,sd_vvp), which are estimated on all azimuths at all times
#'
#' The algorithm has been tested and developed for altitude layers with \code{hlayer} = 200 m.
#' Smaller widths are not recommended as they may cause instabilities of the volume velocity profiling (VVP)
#' and dealiasing routines, and effectively lead to pseudo-replicated altitude data, since altitudinal patterns
#' smaller than the beam width cannot be resolved.
#'
#' The default radar cross section (11 cm^2) corresponds to the average value found by Dokter et al.
#' in a calibration campaign of a full migration autumn season in western Europe at C-band.
#'
#' Using default values of \code{range.min} and \code{range.max} is recommended.
#' Ranges closer than 5 km tend to be contaminated by too much ground clutter, while range gates beyond
#' 25 km become too wide to resolve the default altitude layer width of 200 metre (see \link[bioRad]{beamwidth})
#'
#' For dealiasing, the torus mapping method by Haase et al. is used
#'
#' At S-band (radar wavelength ~ 10 cm), only \code{dualpol=T} mode is recommended.
#'
#' On repeated calls of vol2bird, the Docker container mount can be reused
#' from one call to the next if the calls share the same \code{mount} argument.
#' Re-mounting a Docker container takes time, therefore it is advised to
#' choose a mountpoint that is a parent directory of all volume files to be processed,
#' such that \code{vol2bird} calls are as fast as possible.
#' @export
#' @references Haase, G. and Landelius, T., 2004. Dealiasing of Doppler radar velocities using a torus mapping. Journal of Atmospheric and Oceanic Technology, 21(10), pp.1566-1573.
#' @examples
#' # locate example volume file:
#' volume <- system.file("extdata", "volume.h5", package="bioRad")
#' # copy to a home directory with read/write permissions:
#' file.copy(volume,"~/volume.h5")
#' # calculate the profile:
#' profile=vol2bird("~/volume.h5")
#' # plot the profile
#' plot(profile)
#' # clean up:
#' file.remove("~/volume.h5")
vol2bird =  function(vol.in, vp.out="", vol.out="",verbose=F,mount=dirname(vol.in),sd_vvp=2,rcs=11,dualpol=F,rhohv=0.9,elev.min=0,elev.max=90,azim.min=0,azim.max=360,range.min=5000,range.max=25000,nlayer=20L,hlayer=200,nyquist.min=4,nyquist.dealias=20,dealias=T){
  # check input arguments
  if(!is.numeric(sd_vvp) || sd_vvp<=0) stop("invalid 'sd_vvp' argument, radial velocity standard deviation threshold should be a positive numeric value")
  if(!is.numeric(rcs) || rcs<=0) stop("invalid 'rcs' argument, radar cross section should be a positive numeric value")
  if(!is.logical(dualpol)) stop("invalid 'dualpol' argument, should be logical")
  if(!is.numeric(rhohv) || rhohv<=0 || rhohv>1) stop("invalid 'rhohv' argument, correlation coefficient treshold should be a numeric value between 0 and 1")
  if(!is.numeric(elev.min) || elev.min< -90 || elev.min>90) stop("invalid 'elev.min' argument, elevation should be between -90 and 90 degrees")
  if(!is.numeric(elev.max) || elev.max< -90 || elev.max>90) stop("invalid 'elev.max' argument, elevation should be between -90 and 90 degrees")
  if(elev.max<elev.min) stop("'elev.max' cannot be larger than 'elev.min'")
  if(!is.numeric(azim.min) || azim.min<0 || azim.min>360) stop("invalid 'azim.min' argument, azimuth should be between 0 and 360 degrees")
  if(!is.numeric(azim.max) || azim.max<0 || azim.max>360) stop("invalid 'azim.max' argument, azimuth should be between 0 and 360 degrees")
  if(!is.numeric(range.min) || range.min<0) stop("invalid 'range.min' argument, range should be a positive numeric value")
  if(!is.numeric(range.max) || range.max<0) stop("invalid 'range.max' argument, range should be a positive numeric value")
  if(range.max<range.min) stop("'rang.max' cannot be larger than 'rang.min'")
  if(!is.integer(nlayer) & nlayer<=0) stop("'nlayer' should be a positive integer")
  if(!is.numeric(hlayer) || hlayer<0) stop("invalid 'hlayer' argument, should be a positive numeric value")
  if(!is.numeric(nyquist.min) || nyquist.min<0) stop("invalid 'nyquist.min' argument, should be a positive numeric value")
  if(!is.numeric(nyquist.dealias) || nyquist.dealias<0) stop("invalid 'nyquist.dealias' argument, should be a positive numeric value")
  if(!is.logical(dealias)) stop("invalid 'dealias' argument, should be logical")
  if(file.access(mount,0)==-1) stop("invalid 'mount' argument. Directory not found")
  if(file.access(mount,2)==-1) stop(paste("invalid 'mount' argument. No write permission in directory",mount))
  if(!docker) stop("Requires a running Docker daemon.\nTo enable vol2bird, start your local Docker daemon, and run 'checkDocker()' in R")
  if(!file.exists(vol.in)) stop("No such file or directory")
  if(!length(verbose)==1 || !is.logical(verbose)) stop("verbose argument should be one of TRUE or FALSE")
  if(vp.out!="" && !file.exists(dirname(vp.out))) stop(paste("output directory",dirname(vp.out),"not found"))
  filedir=dirname(normalizePath(vol.in))
  if(!grepl(normalizePath(mount),filedir)) stop("mountpoint 'mount' has to be a parent directory of input file 'vol.in'")
  profile.tmp=tempfile(tmpdir=filedir)
  if(file.access(filedir,mode=2)<0) stop(paste("vol2bird requires write permission in",filedir))
  if(startContainer(normalizePath(mount))!=0) stop(paste("failed to start vol2bird Docker container"))

  # put options file in place, to be read by vol2bird container
  opt.values=c(as.character(c(sd_vvp,rcs,rhohv,elev.min,elev.max,azim.min,azim.max,range.min,
                 range.max,nlayer,hlayer,nyquist.min)),
                 if(dualpol) "TRUE" else "FALSE",if(dealias) "TRUE" else "FALSE")
  opt.names=c("STDEV_BIRD","SIGMA_BIRD","RHOHVMIN","ELEVMIN","ELEVMAX",
                  "AZIMMIN","AZIMMAX","RANGEMIN","RANGEMAX","NLAYER","HLAYER",
                  "MIN_NYQUIST_VELOCITY","DEALIAS_VRAD","DUALPOL")
  opt=data.frame("option"=opt.names,"is"=rep("=",length(opt.values)),"value"=opt.values)
  optfile=paste(normalizePath(mount),"/options.conf",sep="")
  if(file.exists(optfile)){
    warning(paste("options.conf file found in directory ",mount,". Renamed to options.conf.save to prevent overwrite...", sep=""))
    file.rename(optfile,paste(optfile,".saved",sep=""))
  }
  write.table(opt,file=optfile,col.names=F,row.names=F,quote=F)

  # prepare docker input filenames relative to mountpoint
  prefixstart=if(mount=="/") 1 else 2
  prefix=substring(filedir,prefixstart+nchar(normalizePath(mount)))
  if(nchar(prefix)>0) prefix=paste(prefix,"/",sep="")
  vol.in.docker=paste(prefix,basename(vol.in),sep="")
  profile.tmp.docker=paste(prefix,basename(profile.tmp),sep="")
  if(vol.out!="") vol.out.docker=paste(prefix,basename(vol.out),sep="")
  else vol.out.docker=""

  # run vol2bird container
  result = system(paste("docker exec vol2bird bash -c 'cd data && vol2bird ",vol.in.docker,profile.tmp.docker,vol.out.docker,"'"),ignore.stdout=!verbose)
  if(result!=0){
    file.remove(optfile)
    stop("failed to run vol2bird Docker container")
  }

  # read output into a VP object
  output=readVP(profile.tmp)

  # clean up
  if(vp.out=="") file.remove(profile.tmp)
  else file.rename(profile.tmp,vp.out)
  file.remove(optfile)

  output
}

#' Read vertical profiles from vol2bird stdout
#'
#' @param file A text file containing the standard output (stdout) generated by vol2bird
#' @param radar string containing a radar identifier
#' @param wavelength radar wavelength in cm, or one of 'C' or 'S' for C-band and S-band radar, respectively
#' @export
#' @return an object inhereting from class "\code{VPTimeSeries}", see \link[bioRad]{VPTimeSeries} for details
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM", wavelength='S')
#' ts
readVP.table=function(file,radar,wavelength='C'){
  if(!file.exists(file)) stop(paste("file",file,"doesn't exist"))
  if(missing(radar)) stop("'radar' argument missing. Required to specify a radar identifier")
  if(missing(wavelength)) warning(paste("No 'wavelength' argument provided, assuming radar operates at ",wavelength,"-band",sep=""))
  if(wavelength=='C') wavelength=5.3
  if(wavelength=='S') wavelength=10.6
  if(!is.numeric(wavelength) || length(wavelength)>1) stop("not a valid 'wavelength' argument")
  #header of the data file
  header.names=c("Date","Time","HGHT","u","v","w","ff","dd","sd_vvp","gap","dbz","eta","dens","DBZH","n","n_dbz","n_all","n_dbz_all")
  #read the data
  data=read.table(file=file, header = F, col.names=header.names)
  # convert Time into a POSIXct date-time
  data$datetime <- as.POSIXct(paste(data$Date, sprintf('%04d', data$Time), sep = ""), format = "%Y%m%d%H%M", tz='UTC')
  data$Date<-NULL
  data$Time<-NULL
  # sort
  data=data[with(data, order(datetime, HGHT)),]
  # remove duplicates
  data=unique(data)
  # split into profiles
  data=split(data,data$datetime)
  # verify that profiles can be flattened
  datadim=sapply(1:length(data), function(x) dim(data[[x]]))
  if(length(unique(datadim[1,]))>1){
    mostFrequent=sort(table(datadim[1,]),decreasing=T)[1]
    if(mostFrequent<=1) stop("Profiles are of unequal altitudinal dimensions, unable to merge")
    mostFrequentNBins=as.integer(names(mostFrequent))
    warning(paste("Profiles are of unequal altitudinal dimensions or contain duplicates. Discarding",length(data)-mostFrequent,"of",length(data),"profiles, restricting to",mostFrequentNBins,"altitude bins."))
    data=data[datadim[1,]==mostFrequentNBins]
  }
  # strip the datetime field
  dates=.POSIXct(sapply(1:length(data),function(x) data[[x]]$datetime[1]),tz="UTC")
  data=lapply(data, function(x) { x["datetime"] <- NULL; x })
  # check whether the time series is regular
  difftimes=difftime(dates[-1],dates[-length(dates)],units="secs")
  if(length(unique(difftimes))==1) regular = T else regular = F
  # flatten the profiles
  profile.quantities=names(data[[1]])
  VPsFlat=lapply(profile.quantities, function(quantity) sapply(data,'[[',quantity))
  names(VPsFlat)=profile.quantities
  VPsFlat$HGHT<-NULL
  # prepare output
  heights=data[[1]]$"HGHT"
  interval=unique(heights[-1]-heights[-length(heights)])

  attributes=list(where=data.frame(interval=interval,levels=length(heights)),how=data.frame(wavelength=wavelength))
  output=list(radar=radar,dates=dates,heights=heights,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),timesteps=difftimes,data=VPsFlat,attributes=attributes,regular=regular)
  class(output)="VPTimeSeries"
  output
}

#' Regularize a time series
#'
#' Projects objects of class \code{VPTimeSeries} on a regular time grid
#' @param ts an object inhereting from class \code{VPTimeSeries}, see \link[bioRad]{VPTimeSeries} for details
#' @param interval time interval grid to project on. When '\code{auto}' the median interval in the time series is used
#' @param units optional units of \code{interval}, one of 'secs', 'mins', 'hours','days', 'weeks'. Defaults to 'mins'.
#' @param fill logical. Whether to fill missing timesteps with the values of the closest neighbouring profile
#' @param verbose logical. When \code{TRUE} prints text to console
#' @export
#' @return an object of class \code{VPTimeSeries} with regular time steps
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM", wavelength='S')
#' # regularize the time series on a 5 minute interval grid
#' tsRegular=regularize(ts, interval=5)
regularize=function(ts,interval="auto",units="mins",fill=F,verbose=T){
  stopifnot(inherits(ts, "VPTimeSeries"))
  if (!(units %in% c("secs", "mins", "hours","days", "weeks"))) stop("invalid 'units' argument. Should be one of c('secs', 'mins', 'hours','days', 'weeks')")
  if (interval!="auto" && !is.numeric(interval)) stop("invalid or missing 'interval' argument. Should be a numeric value")
  if (length(units)>1) stop("invalid or missing 'units' argument.")
  if (!is.logical(fill) || length(fill)>1) stop("fill argument should be a logical value")
  if(interval=="auto"){
    dt=as.difftime(median(ts$timesteps),units="secs")
    if(verbose) cat(paste("projecting on",dt,"seconds interval grid...\n"))
  }
  else dt=as.difftime(interval,units=units)
  grid=seq(from=ts$daterange[1],to=ts$daterange[2],by=dt)
  index=sapply(grid,function(x) which.min(abs(ts$dates - x)))
  quantity.names=names(ts$data)
  ts$data=lapply(1:length(ts$data),function(x) ts$data[[x]][,index])
  if(!fill){
    index2=which(abs(ts$dates[index] - grid)>as.double(dt,units="secs"))
    ts$data=lapply(1:length(ts$data),function(x) {
        tmp=ts$data[[x]]
        tmp[,index2]<-NA
        tmp
      }
    )
  }
  names(ts$data)=quantity.names
  ts$dates=grid
  ts$timesteps=rep(as.double(dt,units="secs"),length(grid)-1)
  ts$regular=T
  return(ts)
}

#' Migration traffic rate
#'
#' Migration traffic rate (MTR) for an altitude layer, defined as the
#' number of targets crossing a 1 km line perpendicular to the migratory movement per hour
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @param alt.min minimum altitude in m
#' @param alt.max maximum altitude in m
#' @export
#' @examples
#' ### MTR for a single vertical profile ###
#' mtr(VP)
#'
#' ### MTRs for a list of vertical profiles ###
#' mtr(c(VP,VP))
#'
#' ### MTRs for a time series of vertical profiles ###
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM", wavelength='S')
#' # print migration traffic rates:
#' mtr(ts)
#' # plot migration traffic rates for the full air column:
#' plot(mtr(ts),type='l',xlab="time [UTC]",ylab="MTR [birds/km/h]")
#' #' plot migration traffic rates for altitudes > 1 km above sea level
#' plot(mtr(ts,alt.min=1000),type='l',xlab="time [UTC]",ylab="MTR [birds/km/h]")
mtr <- function (x, ...) UseMethod("mtr", x)

#' @describeIn mtr MTR of a vertical profile
#' @method mtr VP
#' @return class \code{VP}: the migration traffic rate (MTR) individuals/km/h
#' @export
mtr.VP = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VP"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  interval=x$attributes$where$interval
  index=which(x$data$HGHT>alt.min & x$data$HGHT<alt.max)
  mtr=sum(x$data$dens[index] * x$data$ff[index] * interval/1000,na.rm=T)
  return(mtr)
}

#' @describeIn mtr MTR of a list of vertical profiles
#' @method mtr VPList
#' @return class \code{VPList}: a numeric atomic vector with migration traffic rates in individuals/km/h
#' @export
mtr.VPList = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VPList"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  mtr=sapply(x,mtr.VP,alt.min=alt.min,alt.max=alt.max)
  return(mtr)
}

#' @describeIn mtr MTR of a time series of vertical profiles
#' @method mtr VPTimeSeries
#' @return class \code{VPTimeSeries}: a data frame with dates and migration traffic rates in individuals/km/h
#' @export
mtr.VPTimeSeries = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VPTimeSeries"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  interval=x$attributes$where$interval
  index=which(x$heights>alt.min & x$heights<alt.max)
  mtr=colSums(x$data$ff[index,]*x$data$dens[index,],na.rm=T)*interval/1000
  output=data.frame(dates=x$dates,mtr=mtr)
  rownames(output)=NULL
  return(output)
}

#' Class VP: vertical profile
#'
#' Class for vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VP=function(x) print.VP(x)

#' @rdname summary.VP
#' @export
#' @return for \code{is.VP}: \code{TRUE} if its argument is of class "\code{VP}"
is.VP <- function(x) inherits(x, "VP")

#' @rdname summary.VP
#' @export
#' @return for \code{dim.VP}: dimensions of the profile data
dim.VP <- function(x) {
  stopifnot(inherits(x,"VP"))
  dim(x$data)
}

#' Class VPList: list of vertical profiles
#'
#' Class for list of vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VPList=function(x) print.VPList(x)

#' @rdname summary.VPList
#' @export
#' @return for \code{is.VPList}: \code{TRUE} if its argument is of class "\code{VPList}"
is.VPList <- function(x) inherits(x, "VPList")


#' Class VPTimeSeries: time series of vertical profiles
#'
#' Class for single-site time series of vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VPTimeSeries=function(x) print.VPTimeSeries(x)


#' @rdname summary.VPTimeSeries
#' @export
#' @return for \code{is.VPTimeSeries}: \code{TRUE} if its argument is of class "\code{VPTimeSeries}"
is.VPTimeSeries <- function(x) inherits(x, "VPTimeSeries")

#' @rdname summary.VPTimeSeries
#' @export
#' @return for \code{dim.VPTimeSeries}: dimensions of the time series
dim.VPTimeSeries <- function(x) {
  stopifnot(inherits(x,"VPTimeSeries"))
  data.dim=dim(x$data[[1]])
  c(data.dim,length(x$data))
}

#' @rdname summary.VPList
#' @export
#' @keywords internal
`[.VPTimeSeries` <- function(x,i) {
  stopifnot(inherits(x,"VPTimeSeries"))
  if(length(i)<2) stop("Time series should consist more than one profile")
  x$dates=x$dates[i]
  x$daterange=.POSIXct(c(min(x$dates),max(x$dates)),tz="UTC")
  x$timesteps=difftime(x$dates[-1],x$dates[-length(x$dates)],units="secs")
  if(length(unique(x$timesteps))==1) x$regular = T else x$regular = F
  quantity.names=names(x$data)
  x$data=lapply(names(x$data),function(quantity) getElement(x$data,quantity)[,i])
  names(x$data)=quantity.names
  return(x)
}

#' Radar cross section
#'
#' Gives the currently assumed radar cross section in cm^2.
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @export
#' @return a radar cross section in cm^2
#' @examples
#' # extract RCS for a single vertical profile:
#' rcs(VP)
rcs <- function (x, ...) UseMethod("rcs", x)

#' @describeIn rcs radar cross section of a vertical profile
#' @method rcs VP
#' @export
rcs.VP <- function (x){
  stopifnot(inherits(x,"VP"))
  x$attributes$how$rcs_bird
}

#' @describeIn rcs radar cross section of a vertical profile
#' @method rcs VPList
#' @export
rcs.VPList <- function (x){
  stopifnot(inherits(x,"VPList"))
  output=sapply(x,`rcs.VP`)
  output
}

#' @describeIn rcs radar cross section of a vertical profile
#' @method rcs VPTimeSeries
#' @export
rcs.VPTimeSeries <- function (x){
  stopifnot(inherits(x,"VPTimeSeries"))
  x$attributes$how$rcs_bird
}

#' Set radar cross section
#'
#' Sets the assumed radar cross section in cm^2. This method also updates the migration densities in \code{x$data$dens}
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @export
#' @examples
#' # change RCS for a single vertical profile:
#' rcs(VP)<-20
`rcs<-` <- function (x, ...) UseMethod("rcs<-", x)

#' @rdname rcs-set
#' @method rcs<- VP

#' @export
`rcs<-.VP` <- function(x,value){
  stopifnot(inherits(x,"VP"))
  x$attributes$how$rcs_bird=value
  x$data$dens=x$data$eta/value
  if(is.numeric(x$attributes$how$sd_vvp_thresh)){
    x$data$dens[x$data$sd_vvp<x$attributes$how$sd_vvp_thresh]=0
  }
  else{
    warning("threshold for sd_vvp not set, defaulting to 2 m/s")
    x$attributes$how$sd_vvp_thresh=2
    x$data$dens[x$data$sd_vvp<2]=0
  }
  x
}

#' @rdname rcs-set
#' @method rcs<- VPList
#' @export
`rcs<-.VPList` <- function(x,value){
  stopifnot(inherits(x,"VPList"))
  output=lapply(x,`rcs<-.VP`,value=value)
  class(output)="VPList"
  output
}

#' @rdname rcs-set
#' @method rcs<- VPTimeSeries
#' @export
`rcs<-.VPTimeSeries` <- function(x,value){
  stopifnot(inherits(x,"VPTimeSeries"))
  x$attributes$how$rcs_bird=value
  x$data$dens=x$data$eta/value
  if(is.numeric(x$attributes$how$sd_vvp_thresh)){
    x$data$dens[x$data$sd_vvp<x$attributes$how$sd_vvp_thresh]=0
  }
  else{
    warning("threshold for sd_vvp not set, defaulting to 2 m/s")
    x$attributes$how$sd_vvp_thresh=2
    x$data$dens[x$data$sd_vvp<2]=0
  }
  x
}

#' VVP-retrieved radial velocity standard deviation
#'
#' Gives the current threshold in VVP-retrieved radial velocity standard deviation in m/s.
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @export
#' @return threshold for \code{sd_vvp} in m/s.
#' @examples
#' # extract threshold for a single vertical profile:
#' sd_vvp(VP)
sd_vvp <- function (x, ...) UseMethod("sd_vvp", x)

#' @describeIn sd_vvp threshold in VVP-retrieved radial velocity standard deviation of a vertical profile
#' @method rcs VP
#' @export
sd_vvp.VP <- function (x){
  stopifnot(inherits(x,"VP"))
  x$attributes$how$sd_vvp_thresh
}

#' @describeIn sd_vvp threshold in VVP-retrieved radial velocity standard deviation of a list of vertical profiles
#' @method sd_vvp VPList
#' @export
sd_vvp.VPList <- function (x){
  stopifnot(inherits(x,"VPList"))
  output=sapply(x,`sd_vvp.VP`)
  output
}

#' @describeIn sd_vvp threshold in VVP-retrieved radial velocity standard deviation of a time series of vertical profiles
#' @method sd_vvp VPTimeSeries
#' @export
sd_vvp.VPTimeSeries <- function (x){
  stopifnot(inherits(x,"VPTimeSeries"))
  x$attributes$how$sd_vvp_thresh
}

#' Set threshold for VVP-retrieved radial velocity standard deviation
#'
#' Sets the threshold in \code{sd_vvp}. Altitude layers with \code{sd_vvp} below this threshold are
#' assumed to have an aerial density of zero individuals. This method updates the migration densities in \code{x$data$dens}
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @export
#' @examples
#' # change threshold for a single vertical profile:
#' sd_vvp(VP)<-2
`sd_vvp<-` <- function (x, ...) UseMethod("sd_vvp<-", x)

#' @rdname sd_vvp-set
#' @method sd_vvp<- VP

#' @export
`sd_vvp<-.VP` <- function(x,value){
  stopifnot(inherits(x,"VP"))
  x$attributes$how$sd_vvp_thresh=value
  if(is.numeric(x$attributes$how$rcs_bird)){
    x$data$dens=x$data$eta/x$attributes$how$rcs_bird
    x$data$dens[x$data$sd_vvp<value]=0
  }
  else{
    warning("radar cross section not set, defaulting to 11 cm^2 ...")
    x$data$dens=x$data$eta/11
    x$attributes$how$rcs_bird=11
    x$data$dens[x$data$sd_vvp<value]=0
  }
  x
}

#' @rdname sd_vvp-set
#' @method sd_vvp<- VPList
#' @export
`sd_vvp<-.VPList` <- function(x,value){
  stopifnot(inherits(x,"VPList"))
  output=lapply(x,`sd_vvp<-.VP`,value=value)
  class(output)="VPList"
  output
}

#' @rdname sd_vvp-set
#' @method sd_vvp<- VPTimeSeries
#' @export
`sd_vvp<-.VPTimeSeries` <- function(x,value){
  stopifnot(inherits(x,"VPTimeSeries"))
  x$attributes$how$sd_vvp_thresh=value
  if(is.numeric(x$attributes$how$rcs_bird)){
    x$data$dens=x$data$eta/x$attributes$how$rcs_bird
    x$data$dens[x$data$sd_vvp<value]=0
  }
  else{
    warning("radar cross section not set, defaulting to 11 cm^2 ...")
    x$data$dens=x$data$eta/11
    x$attributes$how$rcs_bird=11
    x$data$dens[x$data$sd_vvp<value]=0
  }
  x
}


#' Migration traffic
#'
#' Total migration traffic, which is calculated by time-integration
#' of migration traffic rates. Migration traffic gives the number of individuals
#' that have passed per km perpendicular to the migratory direction at the
#' position of the radar for the full period of the time series
#' within the specified altitude band.
#' @param x an object inhereting from class '\code{VPTimeSeries}'
#' @inheritParams mtr
#' @export
#' @return a numeric value equal to migration traffic in number of individuals / km
mt <- function(x,alt.min=0, alt.max=Inf){
  stopifnot(inherits(x,"VPTimeSeries"))
  dt=(c(0,x$timesteps)+c(x$timesteps,0))/2
  # convert to hours
  dt=as.numeric(dt)/3600
  sum(dt*mtr(x,alt.min,alt.max)$mtr)
}

#' Cumulative migration traffic
#'
#' Cumulative migration traffic is calculated as the cumulative sum of
#' of the migration traffic within each time step of a time series.
#' Cumulative migration traffic gives the number of individuals
#' that have passed per km perpendicular to the migratory direction at the
#' position of the radar as a function time from the start of time series
#' within the specified altitude band.
#' @param x an object inhereting from class '\code{VPTimeSeries}'
#' @inheritParams mtr
#' @export
#' @return a numeric value equal to migration traffic in number of individuals / km
#' @examples
#' # get the VPTS example dataset:
#' data(VPTS)
#' # print cumulative migration traffic to console:
#' cmt(VPTS)
#' # plot cumulative migration traffic:
#' plot(cmt(VPTS),type='l',xlab="time [UTC]",ylab="CMT [birds/km]")
cmt <- function(x,alt.min=0, alt.max=Inf){
  stopifnot(inherits(x,"VPTimeSeries"))
  dt=(c(0,x$timesteps)+c(x$timesteps,0))/2
  # convert to hours
  dt=as.numeric(dt)/3600
  mtrs=mtr(x,alt.min,alt.max)
  data.frame(dates=mtrs$dates,cmt=cumsum(dt*mtrs$mtr))
}

# function obtained via Hidde Leijnse, source unknown
#' calculate sunrise and sunset
#' @param lon longitude in decimal degrees
#' @param lat latitude in decimal degrees
#' @param date date inhereting from class "\code{POSIXt}" or a string interpretable by \link[base]{as.Date}
#' @param elev sun elevation in degrees
#' @param rise whether to output for rising or setting sun
#' @export
#' @return the moment of sunrise or sunset in UTC time
#' @details The angular diameter of the sun is about 0.536 degrees, therefore the moment
#' of sunrise/sunset corresponds to half that elevation at -0.268 degrees.
#'
#' Note that for a given date and location, sunrise time can be after sunset time when
#' the moments of sunset and sunrise are not on the same day within the UTC time zone.
#'
#' Approximate astronomical formula are used, therefore the moment of sunrise / sunset may
#' be off by a few minutes
#' @examples
#' # sunrise in the Netherlands
#' suntime(5,53,"2016-01-01")
#' # sunset in the Netherlands
#' suntime(5,53,"2016-01-01",rise=F)
#' # civil twilight in Ithaca, NY, today
#' suntime(-76.5,42.4,Sys.time(),elev=-6)
suntime = function(lon, lat, date, elev=-0.268, rise = TRUE)
{
  dateOnly=as.Date(date)
  #Convert date to julian day
  yyyy = as.numeric(format(dateOnly,"%Y"))
  mm = as.numeric(format(dateOnly,"%m"))
  dd = as.numeric(format(dateOnly,"%d"))
  jy=yyyy

  if (any(jy == 0)) stop("get_time_sun: there is no year zero!")
  jy[jy < 0] = jy[jy < 0] + 1
  jm = mm
  jm[mm > 2] = mm[mm > 2] + 1
  jy[mm <= 2] = jy[mm <= 2] - 1
  jm[mm <= 2] = mm[mm <= 2] + 13
  julday = floor(365.25 * jy) + floor(30.6001 * jm) + dd + 1720995
  julday[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))] = julday[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))] + 2 - floor(0.01 * jy[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))]) + floor(0.25 * floor(0.01 * jy[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))]))
  julday0 = 2451545	#Julian day for 20000101

  #Calculation of eclips coordinates
  MeanLon = 280.460 + 0.9856474 * (julday - julday0)
  MeanAnom = 357.528 + 0.9856003 * (julday - julday0)
  EclipLon = MeanLon + 1.915 * sin(MeanAnom * pi / 180) + 0.020 * sin(2 * MeanAnom * pi / 180)
  EclipLon = EclipLon * pi / 180
  Obliquity = 23.439 - 0.0000004 * (julday - julday0)
  Obliquity = Obliquity * pi / 180

  #Calculation of the celestial coordinates of the sun
  RightAsc = atan2(cos(Obliquity) * sin(EclipLon), cos(EclipLon))
  Declinat = asin(sin(Obliquity) * sin(EclipLon))

  #Calculation of current, local hour angle
  acos_arg = (sin(elev * pi / 180) - sin(Declinat) * sin(lat * pi / 180)) / (cos(Declinat) * cos(lat * pi / 180))
  angleH = seq(1, 1, length.out = length(acos_arg)) * NA
  angleH[abs(acos_arg) <= 1] = acos(acos_arg[abs(acos_arg) <= 1])

  #Determine sign of the derivative to see if the sun is rising or setting
  if (rise) sign_angle = 1
  else sign_angle = -1
  sign_angle = -1 * sign_angle * sign(cos(Declinat) * cos(lat * pi / 180) * sin(angleH))
  sign_angle[sign_angle == 0] = 1

  #Determine time
  GMST = (sign_angle * angleH - lon * pi / 180 + RightAsc) / 15
  hour = GMST * 180 / pi - 6.697375 - 0.0657098242 * (julday - julday0)
  hour = hour - floor(hour / 24) * 24

  output=as.POSIXct(as.POSIXlt(dateOnly,tz='UTC'))+3600*hour
  return(output)
}

#' Elevation
#'
#' Gives the elevation of a scan, or the elevations within a polar volume
#' @param x a \code{PVOL} or \code{SCAN} object
#' @export
#' @return elevation in degrees
#' @examples
#' # to be written
elev <- function (x, ...) UseMethod("elev", x)

#' @describeIn elev elevation of a scan
#' @method elev SCAN
#' @export
elev.SCAN = function(x){
  stopifnot(inherits(x,"SCAN"))
  x$attributes$where$elangle
}

#' @describeIn elev elevation of a polar volume
#' @method elev PVOL
#' @export
elev.PVOL = function(x){
  stopifnot(inherits(x,"PVOL"))
  sapply(x$scans,elev.SCAN)
}

