#' Analyze and visualize biological signals in weather radar data
#'
#' @references
#' \itemize{
#'  \item Bird migration flight altitudes studied by a network of operational weather radars, Dokter et al., J. R. Soc. Interace 8 (54), pp. 30--43, 2011. DOI \href{http://dx.doi.org/10.1098/rsif.2010.0116}{10.1098/rsif.2010.0116}
#' }
#'
#'
#' @import h5
#' @import fields

"_PACKAGE"
#> [1] "_PACKAGE"


#VP=readVP("~/git/bioRad/inst/extdata/profile.h5")
#save(VP,file="~/git/bioRad/data/VP.RData")
#' Example object of class \code{VP} as generated by \code{\link{readVP}}
"VP"

# locate example file:
# VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
# load time series:
# VPTS=readVP.table(VPtable,radar="KBGM", wavelength='S')
# save(VPTS,file="~/git/bioRad/data/VPTS.RData")
#' Example object of class \code{VPTimeSeries}
"VPTS"

docker=F

#' Checks that Docker is running
#'
#' Checks that \href{https://www.docker.com/}{Docker} daemon is running correctly on the local system
#' @param verbose logical which indicates whether to print test results to R console
#' @export
checkDocker = function(verbose=T){
  system("docker rm -f hello-world",ignore.stderr=T,ignore.stdout=T)
  result=system("docker run --name hello-world hello-world",ignore.stderr=!verbose,ignore.stdout=!verbose)
  unlockBinding("docker", environment(checkDocker))
  environment(checkDocker)$docker=(result==0)
  lockBinding("docker", environment(checkDocker))
  if(!verbose) return(result)
}

setLoadActions(function(ns)
  cat("Loading package", sQuote(getNamespaceName(ns)), "...\n"),
  function(ns) if((checkDocker(verbose=F)!=0)){
    cat("Warning: no running Docker daemon found\n")
    cat("Warning:",getNamespaceName(ns),"functionality requiring Docker has been disabled\n\n")
    cat("To enable Docker functionality, start Docker and run 'checkDocker()' in R")
    unlockBinding("docker", environment(checkDocker))
    assign("docker", F, envir = ns)
  }
  else{
    cat("Docker daemon running, Docker functionality enabled.\n")
  }
)

readOdimProfileData = function(file,group){
  whatgroup = file[sprintf("%s/what",group)]
  nodata=h5attr(whatgroup,"nodata")
  undetect=h5attr(whatgroup,"undetect")
  gain=h5attr(whatgroup,"gain")
  offset=h5attr(whatgroup,"offset")
  dset=file[sprintf("%s/data",group)]
  data=readDataSet(dset)
  data=replace(data,data==nodata,NA)
  data=replace(data,data==undetect,NaN)
  h5close(dset)
  h5close(whatgroup)
  offset+gain*data
}

quantityName = function(file,group){
  whatgroup=file[paste(group,"/what",sep="")]
  quantity=h5attr(whatgroup,"quantity")
  h5close(whatgroup)
  quantity
}

#' Read a vertical profile (VP) from file
#'
#' @param filename A string containing the path to a vertical profile generated by \link[bioRad]{vol2bird}
#' @export
#' @return an object of class \code{VP}, which is a list containing
#' \describe{
#'  \item{\strong{\code{radar}}}{the radar identifier}
#'  \item{\strong{\code{datetime}}}{the nominal time of the profile [UTC]}
#'  \item{\strong{\code{data}}}{the profile data, a list containing:
#'    \describe{
#'        \item{\code{HGHT}}{height above mean sea level [m]. Alt. bin from HGHT to HGHT+interval)}
#'        \item{\code{u}}{speed component west to east [m/s]}
#'        \item{\code{v}}{speed component north to south [m/s]}
#'        \item{\code{w}}{vertical speed (unreliable!) [m/s]}
#'        \item{\code{ff}}{horizontal speed [m/s]}
#'        \item{\code{dd}}{direction [degrees, clockwise from north]}
#'        \item{\code{sd_vvp}}{VVP radial velocity standard deviation direction [m/s]}
#'        \item{\code{gap}}{Angular data gap detected [T/F]}
#'        \item{\code{dbz}}{Bird reflectivity factor [dBZ]}
#'        \item{\code{eta}}{Bird reflectivity [cm^2/km^3]}
#'        \item{\code{dens}}{Bird density [birds/km^3]}
#'        \item{\code{DBZH}}{Total reflectivity factor (bio+meteo scattering) [dBZ]}
#'        \item{\code{n}}{number of points VVP bird velocity analysis}
#'        \item{\code{n_dbz}}{number of points bird density estimate}
#'        \item{\code{n_all}}{number of points VVP velocity Stdev analysis}
#'        \item{\code{n_all_dbz}}{number of points total reflectivity estimate}
#'    }
#'  }
#'  \item{\strong{\code{attributes}}}{list with the profile's \code{\\what}, \code{\\where} and \code{\\how} attributes}
#' }
#' @examples
#' # locate example profile file:
#' prof <- system.file("extdata", "profile.h5", package="bioRad")
#' # print the local path of the profile file:
#' prof
#' # load the file:
#' readVP(prof)
#'
readVP = function(filename){
  if(!is.VPfile(filename)) return(NULL)
  file = h5file(filename,mode="r")
  #check input argument
  if(!inherits(file,"H5File")) stop("'file' should be a HDF5 file")
  if(!existsGroup(file,"dataset1")){
    h5close(file)
    stop("HDF5 file does not contain a /dataset1 group")
  }

  #extract quantities
  dataset1=file["dataset1"]
  groups=list.groups(dataset1,recursive=F)
  quantities=sapply(groups,function(x) quantityName(file,x))
  profile=as.data.frame(lapply(groups,function(x) readOdimProfileData(file,x)))
  names(profile)=quantities

  #extract attributes
  howgroup=file["how"]
  whatgroup=file["what"]
  wheregroup=file["where"]
  attribNames.how=list.attributes(howgroup)
  attribNames.what=list.attributes(whatgroup)
  attribNames.where=list.attributes(wheregroup)
  attribs.how=lapply(attribNames.how,function(x) h5attr(howgroup,x))
  attribs.what=lapply(attribNames.what,function(x) h5attr(whatgroup,x))
  attribs.where=lapply(attribNames.where,function(x) h5attr(wheregroup,x))
  names(attribs.how)=attribNames.how
  names(attribs.what)=attribNames.what
  names(attribs.where)=attribNames.where

  #convert some useful metadata
  datetime=as.POSIXct(paste(attribs.what$date, attribs.what$time), format = "%Y%m%d %H%M%S", tz='UTC')
  sources=strsplit(attribs.what$source,",")[[1]]
  radar=gsub("RAD:","",sources[which(grepl("RAD:",sources))])

  #prepare output
  output=list(radar=radar,datetime=datetime,data=profile,attributes=list(how=attribs.how,what=attribs.what,where=attribs.where))
  class(output) = "VP"
  h5close(dataset1)
  h5close(howgroup)
  h5close(wheregroup)
  h5close(whatgroup)
  h5close(file)
  output
}

#' Read a polar volume (PVOL) from file
#'
#' @param filename A string containing the path to a vertical profile generated by \link[bioRad]{vol2bird}
#' @export
#' @return an object of class \code{PVOL}, which is a list containing polar scans, i.e. objects of class \code{SCAN}
#' \describe{
#'  \item{\strong{\code{radar}}}{the radar identifier}
#'  \item{\strong{\code{datetime}}}{the nominal time of the volume [UTC]}
#'  \item{\strong{\code{scans}}}{a list with scan objects}
#'  \item{\strong{\code{attributes}}}{list with the volume's \code{\\what}, \code{\\where} and \code{\\how} attributes}
#' }
#' @examples
#' # locate example profile file:
#' pvol <- system.file("extdata", "volume.h5", package="bioRad")
#' # print the local path of the profile file:
#' pvol
#' # load the file:
#' read.pvol(prof)
#'
read.pvol = function(filename){
  if(!is.PVOLfile(filename)) return(NULL)
  file = h5file(filename,mode="r")

  #extract quantities
  dataset1=file["dataset1"]
  groups=list.groups(dataset1,recursive=F)
  quantities=sapply(groups,function(x) quantityName(file,x))
  profile=as.data.frame(lapply(groups,function(x) readOdimProfileData(file,x)))
  names(profile)=quantities

  #extract attributes
  howgroup=file["how"]
  whatgroup=file["what"]
  wheregroup=file["where"]
  attribNames.how=list.attributes(howgroup)
  attribNames.what=list.attributes(whatgroup)
  attribNames.where=list.attributes(wheregroup)
  attribs.how=lapply(attribNames.how,function(x) h5attr(howgroup,x))
  attribs.what=lapply(attribNames.what,function(x) h5attr(whatgroup,x))
  attribs.where=lapply(attribNames.where,function(x) h5attr(wheregroup,x))
  names(attribs.how)=attribNames.how
  names(attribs.what)=attribNames.what
  names(attribs.where)=attribNames.where

  #convert some useful metadata
  datetime=as.POSIXct(paste(attribs.what$date, attribs.what$time), format = "%Y%m%d %H%M%S", tz='UTC')
  sources=strsplit(attribs.what$source,",")[[1]]
  radar=gsub("RAD:","",sources[which(grepl("RAD:",sources))])

  #prepare output
  output=list(radar=radar,datetime=datetime,data=profile,attributes=list(how=attribs.how,what=attribs.what,where=attribs.where))
  class(output) = "VP"
  h5close(dataset1)
  h5close(howgroup)
  h5close(wheregroup)
  h5close(whatgroup)
  h5close(file)
  output
}


#' Check whether file is a vertical profile
#'
#' Checker whether a file is a vertical profile that can be read with package \pkg{bioRad}
#'
#' @param filename A string containing a filename
#' @export
#' @return TRUE when \code{filename} is a vertical profile, otherwise FALSE
#' @examples
#' is.VPfile("/not/a/valid/VP/file.h5")   #> FALSE
#'
is.VPfile = function(filename){
  type=h5ODIMobject(filename)
  if(is.na(type)) return(FALSE)
  else return(type=="VP")
}

#' Check whether file is a polar volume
#'
#' Checker whether a file is a polar volume that can be read with package \pkg{bioRad}
#'
#' @param filename A string containing a filename
#' @export
#' @return TRUE when \code{filename} is a polar volume in readable format, otherwise FALSE
#' @examples
#' is.PVOLfile("/not/a/valid/PVOL/file.h5")   #> FALSE
#'
is.PVOLfile = function(filename){
  type=h5ODIMobject(filename)
  if(is.na(type)) return(FALSE)
  else return(type=="PVOL")
}

#' Check ODIM HDF5 data class
#'
#' Checks which data class is contained in ODIM HDF5 file
#'
#' @param filename A string containing a filename
#' @export
#' @return character string "\code{PVOL}" for polar volume, "\code{VP}" for vertical profile, otherwise \code{NA}
#' @examples
#' # locate a polar volume file
#' pvol <- system.file("extdata", "volume.h5", package="bioRad")
#' h5ODIMobject(pvol)   #> "PVOL"
#'
h5ODIMobject = function(filename){
  if(!is.ODIMfile(filename)){
    warning(paste(filename,"is not a ODIM HDF5 file"))
    return(NA)
  }
  file = h5file(filename,mode="r")
  object=h5attr(file["what"],"object")
  h5close(file)
  return(object)
}

is.ODIMfile = function(filename){
  if(!is.h5file(filename)){
    warning(paste(filename,"is not a HDF5 file"))
    return(FALSE)
  }
  file = h5file(filename,mode="r")
  output = T
  if(!existsGroup(file,"dataset1")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /dataset1 group"))
  }
  if(!existsGroup(file,"what")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /what group"))
  }
  else{
    if("object" %in% list.attributes(file["what"])){
      object=h5attr(file["what"],"object")
    }
    else{
      warning("'object' attribute not found in /what group")
      output=F
    }
  }
  if(!existsGroup(file,"how")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /how group"))
  }
  if(!existsGroup(file,"where")){
    output = F
    warning(paste("HDF5 file",filename,"does not contain a /where group"))
  }
  h5close(file)
  return(output)
}


#' print method for class \code{VP}
#'
#' @param x An object of class \code{VP}, like the result of a call to \link[bioRad]{readVP}
#' @keywords internal
#' @export
print.VP=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VP"))
  cat("               Vertical profile (class VP)\n\n")
  cat("       radar: ",x$radar,"\n")
  cat("      source: ",x$attributes$what$source,"\n")
  cat("nominal time: ",as.character(x$datetime),"\n")
  cat("generated by: ",paste(x$attributes$how$task,x$attributes$how$task_version),"\n")
}

#' Plot a vertical profile
#'
#' @param x a VP class object
#' @param xlab a title for the x axis
#' @param ylab a title for the y axis
#' @param line.col Color of the plotted curve
#' @param line.lwd Line width of the plotted curve
#' @param main an overall title for the plot
#' @param ... Additional arguments to be passed to the low level \link[graphics]{plot} plotting function
#' @export
#' @examples
#' data(VP)
#' plot(VP)
#' plot(VP,line.col='blue')
plot.VP=function(x, xlab="density [#/km^3]",ylab="height [km]",main="Vertical profile",line.col='red',line.lwd=1,...){
  plot(x$data$dens,x$data$HGHT/1000,xlab=xlab,ylab=ylab,main=main,...)
  points(x$data$dens,x$data$HGHT/1000, col=line.col,lwd=line.lwd,type="l")
}

#' Read a list of vertical profiles from multiple files
#'
#' @param files A string vector containing the filenames of vertical profiles in ODIM HDF5 format generated by \link[bioRad]{vol2bird}
#' @export
#' @return an object of class \code{VPList}, which is a list \code{VP} objects
#' @examples
#' \dontrun{readVP(c("my/path/profile1.h5","my/path/profile2.h5", ...))}
#'
readVP.list=function(files){
  VPs=lapply(files,readVP)
  # remove nulls
  VPs <- VPs[!sapply(VPs, is.null)]
  do.call(c.VP,VPs)
}


#' concatenate \code{VP} objects into a \code{VPList} object
#' @param ... objects of class \code{VP}
#' @export
#' @keywords internal
#' @return an object of class \code{VPList}, see \link[bioRad]{readVP.list} for details
c.VP = function(...){
  VPs=list(...)
  VPtest=sapply(VPs,function(x) is(x,"VP"))
  if(FALSE %in% VPtest) {
    warning("non-VP objects found, returning a standard list...")
    return(VPs)
  }
  # extract radar identifiers
  radars=unique(sapply(VPs,'[[',"radar"))
  if(length(radars)>1) warning("Vertical profiles are not from a single radar")
  # extract date-times
  dates=.POSIXct(do.call("c",lapply(VPs,'[[',"datetime")),tz="UTC")
  output=list(VPList=VPs,radar=radars,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),dates=dates)
  output=VPs
  class(output)="VPList"
  output
}

#' @rdname summary.VPList
#' @export
#' @keywords internal
`[.VPList` <- function(x,i) {
  stopifnot(inherits(x,"VPList"))
  if(length(i)==1) return(x[[i]])
  output=unclass(x)[i]
  class(output)="VPList"
  return(output)
}

#' print method for class \code{VPList}
#'
#' @param x An object of class \code{VPList}, usually a result of a call to \link[bioRad]{readVP.list}
#' @keywords internal
#' @export
print.VPList=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VPList"))
  # extract radar identifiers
  radar=unique(sapply(x,'[[',"radar"))
  # extract date-times
  dates=.POSIXct(do.call("c",lapply(x,'[[',"datetime")),tz="UTC")
  daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC")
  cat("                   List of vertical profiles (class VPList)\n\n")
  cat("          radars: ",radar,"\n")
  cat("      # profiles: ",length(x),"\n")
  cat("time range (UTC): ",as.character(daterange[1]),"-",as.character(daterange[2]),"\n")
}

#' Convert \code{VPList} to a single radar time series
#'
#' @param x An object of class \code{VPList}, usually a result of a call to \link[bioRad]{readVP.list}
#' @param radar string containing the radar identifier to generate time series for. Only required when \code{VPList} object contains multiple radars
#' @export
#' @return an object of class \code{VPTimeSeries}, which is a list containing
#' \describe{
#'  \item{\code{radar}}{string containing the radar identifier}
#'  \item{\code{dates}}{the \code{N} nominal times of the profiles}
#'  \item{\code{heights}}{the \code{M} heights of the layers in the profile}
#'  \item{\code{daterange}}{the minimum and maximum nominal time of the profiles in the list}
#'  \item{\code{timesteps}}{time differences between the profiles. Element \code{i} gives the time difference between profile \code{i} and \code{i+1}}
#'  \item{\code{data}}{list of \code{N} by \code{M} matrices containing the vertical profiles for each quantity.
#'                     For a description of available quantities, see the \code{data} element of the \code{VP} class in \link[bioRad]{readVP}}
#'  \item{\code{attributes}}{profile attributes, copied from the first profile contained in \code{x}}
#'  \item{\code{regular}}{logical indicating whether the time series is regular or not}
#' }
#' @examples
#' \dontrun{readVP(c("my/path/profile1.h5","my/path/profile2.h5", ...))}
#'
VPTimeSeries=function(x,radar=NA){
  stopifnot(inherits(x, "VPList"))
  # extract radar identifiers
  radars=sapply(x,'[[',"radar")
  uniqueRadars=unique(radars)
  # extract date-times
  dates=.POSIXct(do.call("c",lapply(x,'[[',"datetime")),tz="UTC")
  daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC")
  if(length(uniqueRadars)>1 & is.na(radar)) stop("vertical profile list of multiple radars, select one with 'radar' argument")
  if(!is.na(radar) & !(radar %in% uniqueRadars)) stop(paste("no profiles found for radar",radar))
  if(is.na(radar) & length(uniqueRadars==1)) radar=uniqueRadars
  index=which(radars==radar)
  VPs=x[index]
  # sort by datetime
  VPs=VPs[order(sapply(VPs,'[[',"datetime"))]
  dates=.POSIXct(do.call("c",lapply(VPs,'[[',"datetime")),tz="UTC")
  difftimes=difftime(dates[-1],dates[-length(dates)],units="secs")
  profile.quantities=names(VPs[[1]]$data)

  where.attributes=sapply(lapply(VPs,'[[',"attributes"),'[[',"where")
  if(length(unique(unlist(where.attributes["interval",])))>1) stop("vertical profiles have different altitude bin size")
  if(length(unique(unlist(where.attributes["levels",])))>1) stop("vertical profiles have different number of altitude bins")
  if(length(unique(unlist(where.attributes["maxheight",])))>1) stop("vertical profiles have different maxheight")
  if(length(unique(unlist(where.attributes["minheight",])))>1) stop("vertical profiles have different minheight")
  VPsFlat=lapply(profile.quantities, function(quantity) sapply(lapply(VPs,'[[',"data"),'[[',quantity))
  names(VPsFlat)=profile.quantities
  if(length(unique(difftimes))==1) regular = T else regular = F
  VPsFlat$HGHT<-NULL
  output=list(radar=radar,dates=dates,heights=VPs[[1]]$data$HGHT,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),timesteps=difftimes,data=VPsFlat,attributes=VPs[[1]]$attributes,regular=regular)
  class(output)="VPTimeSeries"
  output
}

#' print method for class \code{VPTimeSeries}
#'
#' @param x An object of class \code{VPTimeSeries}, usually a result of a call to \link[bioRad]{VPTimeSeries}
#' @keywords internal
#' @export
print.VPTimeSeries=function(x,digits = max(3L, getOption("digits") - 3L), ...){
  stopifnot(inherits(x, "VPTimeSeries"))
  cat("                  ",if(x$regular) "Regular" else "Irregular","time series of vertical profiles (class VPTimeSeries)\n\n")
  cat("           radar: ",x$radar,"\n")
  cat("      # profiles: ",length(x$dates),"\n")
  cat("time range (UTC): ",as.character(x$daterange[1]),"-",as.character(x$daterange[2]),"\n")
  if(x$regular) cat("   time step (s): ",min(x$timesteps),"\n")
  else cat("   time step (s): ","min:",min(x$timesteps),"    max: ",max(x$timesteps),"\n")
}

#' Calculate a vertical profile of birds (VPB)
#'
#' Calculates a vertical profile of birds (VPB) from a polar volume
#'
#' @param volume.in A radar file containing a radar polar volume, either in
#' \href{http://www.eumetnet.eu/sites/default/files/OPERA2014_O4_ODIM_H5-v2.2.pdf}{ODIM}
#' format, which is the implementation of the OPERA data information model in \href{https://support.hdfgroup.org/HDF5/}{HDF5} format,
#' or a format supported by the \href{http://trmm-fc.gsfc.nasa.gov/trmm_gv/software/rsl/}{RSL library})
#' @param profile.out character string. Filename for the vertical profile to be generated in ODIM HDF5 format (optional)
#' @param volume.out character string. Filename for the polar volume to be generated in ODIM HDF5 format (optional, e.g. for converting RSL formats to ODIM)
#' @param verbose logical. When TRUE, pipe Docker stdout to R console
#' @details Requires a running \href{https://www.docker.com/}{Docker} daemon
#' @export
#' @examples
#' # locate example volume file:
#' volume <- system.file("extdata", "volume.h5", package="bioRad")
#' # copy to a home directory with read/write permissions:
#' file.copy(volume,"~/volume.h5")
#' # calculate the profile:
#' profile=vol2bird("~/volume.h5")
#' # plot the profile
#' plot(profile)
#' # clean up:
#' file.remove("~/volume.h5")
vol2bird =  function(volume.in, profile.out="", volume.out="",verbose=F){
  if(!docker) stop("Requires a running Docker daemon.\nTo enable vol2bird, start your local Docker daemon, and run 'checkDocker()' in R")
  if(!file.exists(volume.in)) stop("No such file or directory")
  if(!length(verbose)==1 || !is.logical(verbose)) stop("verbose argument should be one of TRUE or FALSE")
  if(profile.out!="" && !file.exists(dirname(profile.out))) stop(paste("output directory",dirname(profile.out),"not found"))
  filedir=dirname(normalizePath(volume.in))
  profile.tmp=tempfile(tmpdir=filedir)
  if(file.access(filedir,mode=2)<0) stop(paste("vol2bird requires write permission in",filedir))
  system("docker rm -f vol2bird", ignore.stderr=T,ignore.stdout=T)
  result=system(paste("docker run -v ",filedir,":/data -d --name vol2bird adokter/vol2bird sleep infinity",sep=""),ignore.stdout=T)
  if(result!=0) stop(paste("failed to mount",filedir,"... Go to 'Docker -> preferences -> File Sharing' and add this directory (or its root directory) as a bind mounted directory"))
  system(paste("docker exec vol2bird bash -c 'cd data && vol2bird ",basename(volume.in),basename(profile.tmp),volume.out,"'"),ignore.stdout=!verbose)
  system("docker rm -f vol2bird", ignore.stderr=T,ignore.stdout=T)
  output=readVP(profile.tmp)
  if(profile.out=="") file.remove(profile.tmp)
  else file.rename(profile.tmp,profile.out)
  output
}

#' Read vertical profiles from vol2bird stdout
#'
#' @param file A text file containing the standard output (stdout) generated by vol2bird
#' @param radar string containing a radar identifier
#' @param wavelength radar wavelength in cm, or one of 'C' or 'S' for C-band and S-band radar, respectively
#' @export
#' @return an object inhereting from class "\code{VPTimeSeries}", see \link[bioRad]{VPTimeSeries} for details
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM", wavelength='S')
#' ts
readVP.table=function(file,radar,wavelength='C'){
  if(!file.exists(file)) stop(paste("file",file,"doesn't exist"))
  if(missing(radar)) stop("'radar' argument missing. Required to specify a radar identifier")
  if(missing(wavelength)) warning(paste("No 'wavelength' argument provided, assuming radar operates at ",wavelength,"-band",sep=""))
  if(wavelength=='C') wavelength=5.3
  if(wavelength=='S') wavelength=10.6
  if(!is.numeric(wavelength) || length(wavelength)>1) stop("not a valid 'wavelength' argument")
  #header of the data file
  header.names=c("Date","Time","HGHT","u","v","w","ff","dd","sd_vvp","gap","dbz","eta","dens","DBZH","n","n_dbz","n_all","n_dbz_all")
  #read the data
  data=read.table(file=file, header = F, col.names=header.names)
  # convert Time into a POSIXct date-time
  data$datetime <- as.POSIXct(paste(data$Date, sprintf('%04d', data$Time), sep = ""), format = "%Y%m%d%H%M", tz='UTC')
  data$Date<-NULL
  data$Time<-NULL
  # sort
  data=data[with(data, order(datetime, HGHT)),]
  # remove duplicates
  data=unique(data)
  # split into profiles
  data=split(data,data$datetime)
  # verify that profiles can be flattened
  datadim=sapply(1:length(data), function(x) dim(data[[x]]))
  if(length(unique(datadim[1,]))>1){
    mostFrequent=sort(table(datadim[1,]),decreasing=T)[1]
    if(mostFrequent<=1) stop("Profiles are of unequal altitudinal dimensions, unable to merge")
    mostFrequentNBins=as.integer(names(mostFrequent))
    warning(paste("Profiles are of unequal altitudinal dimensions or contain duplicates. Discarding",length(data)-mostFrequent,"of",length(data),"profiles, restricting to",mostFrequentNBins,"altitude bins."))
    data=data[datadim[1,]==mostFrequentNBins]
  }
  # strip the datetime field
  dates=.POSIXct(sapply(1:length(data),function(x) data[[x]]$datetime[1]),tz="UTC")
  data=lapply(data, function(x) { x["datetime"] <- NULL; x })
  # check whether the time series is regular
  difftimes=difftime(dates[-1],dates[-length(dates)],units="secs")
  if(length(unique(difftimes))==1) regular = T else regular = F
  # flatten the profiles
  profile.quantities=names(data[[1]])
  VPsFlat=lapply(profile.quantities, function(quantity) sapply(data,'[[',quantity))
  names(VPsFlat)=profile.quantities
  VPsFlat$HGHT<-NULL
  # prepare output
  heights=data[[1]]$"HGHT"
  interval=unique(heights[-1]-heights[-length(heights)])
  attributes=list(where=data.frame(interval=interval,levels=length(heights)),how=data.frame(wavelength=wavelength))
  output=list(radar=radar,dates=dates,heights=heights,daterange=.POSIXct(c(min(dates),max(dates)),tz="UTC"),timesteps=difftimes,data=VPsFlat,attributes=attributes,regular=regular)
  class(output)="VPTimeSeries"
  output
}

#' Regularize a time series
#'
#' Projects objects of class \code{VPTimeSeries} on a regular time grid
#' @param ts an object inhereting from class \code{VPTimeSeries}, see \link[bioRad]{VPTimeSeries} for details
#' @param interval time interval grid to project on. When '\code{auto}' the median interval in the time series is used
#' @param units optional units of \code{interval}, one of 'secs', 'mins', 'hours','days', 'weeks'. Defaults to 'mins'.
#' @param fill logical. Whether to fill missing timesteps with the values of the closest neighbouring profile
#' @param verbose logical. When \code{TRUE} prints text to console
#' @export
#' @return an object of class \code{VPTimeSeries} with regular time steps
#' @examples
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM", wavelength='S')
#' # regularize the time series on a 5 minute interval grid
#' tsRegular=regularize(ts, interval=5)
regularize=function(ts,interval="auto",units="mins",fill=F,verbose=T){
  stopifnot(inherits(ts, "VPTimeSeries"))
  if (!(units %in% c("secs", "mins", "hours","days", "weeks"))) stop("invalid 'units' argument. Should be one of c('secs', 'mins', 'hours','days', 'weeks')")
  if (interval!="auto" && !is.numeric(interval)) stop("invalid or missing 'interval' argument. Should be a numeric value")
  if (length(units)>1) stop("invalid or missing 'units' argument.")
  if (!is.logical(fill) || length(fill)>1) stop("fill argument should be a logical value")
  if(interval=="auto"){
    dt=as.difftime(median(ts$timesteps),units="secs")
    if(verbose) cat(paste("projecting on",dt,"seconds interval grid...\n"))
  }
  else dt=as.difftime(interval,units=units)
  grid=seq(from=ts$daterange[1],to=ts$daterange[2],by=dt)
  index=sapply(grid,function(x) which.min(abs(ts$dates - x)))
  quantity.names=names(ts$data)
  ts$data=lapply(1:length(ts$data),function(x) ts$data[[x]][,index])
  if(!fill){
    index2=which(abs(ts$dates[index] - grid)>as.double(dt,units="secs"))
    ts$data=lapply(1:length(ts$data),function(x) {
        tmp=ts$data[[x]]
        tmp[,index2]<-NA
        tmp
      }
    )
  }
  names(ts$data)=quantity.names
  ts$dates=grid
  ts$timesteps=rep(as.double(dt,units="secs"),length(grid)-1)
  ts$regular=T
  return(ts)
}

#' Migration traffic rate
#'
#' Migration traffic rate (MTR) for an altitude layer, defined as the
#' number of targets crossing a 1 km line perpendicular to the migratory movement per hour
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @param alt.min minimum altitude in m
#' @param alt.max maximum altitude in m
#' @export
#' @examples
#' ### MTR for a single vertical profile ###
#' mtr(VP)
#'
#' ### MTRs for a list of vertical profiles ###
#' mtr(c(VP,VP))
#'
#' ### MTRs for a time series of vertical profiles ###
#' # locate example file:
#' VPtable <- system.file("extdata", "VPtable.txt", package="bioRad")
#' # load time series:
#' ts=readVP.table(VPtable,radar="KBGM", wavelength='S')
#' # print migration traffic rates:
#' mtr(ts)
#' # plot migration traffic rates for the full air column:
#' plot(mtr(ts),type='l',xlab="time [UTC]",ylab="MTR [birds/km/h]")
#' #' plot migration traffic rates for altitudes > 1 km above sea level
#' plot(mtr(ts,alt.min=1000),type='l',xlab="time [UTC]",ylab="MTR [birds/km/h]")
mtr <- function (x, ...) UseMethod("mtr", x)

#' @describeIn mtr MTR of a vertical profile
#' @method mtr VP
#' @return class \code{VP}: the migration traffic rate (MTR) individuals/km/h
#' @export
mtr.VP = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VP"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  interval=x$attributes$where$interval
  index=which(x$data$HGHT>alt.min & x$data$HGHT<alt.max)
  mtr=sum(x$data$dens[index] * x$data$ff[index] * interval/1000,na.rm=T)
  return(mtr)
}

#' @describeIn mtr MTR of a list of vertical profiles
#' @method mtr VPList
#' @return class \code{VPList}: a numeric atomic vector with migration traffic rates in individuals/km/h
#' @export
mtr.VPList = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VPList"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  mtr=sapply(x,mtr.VP,alt.min=alt.min,alt.max=alt.max)
  return(mtr)
}

#' @describeIn mtr MTR of a time series of vertical profiles
#' @method mtr VPTimeSeries
#' @return class \code{VPTimeSeries}: a data frame with dates and migration traffic rates in individuals/km/h
#' @export
mtr.VPTimeSeries = function(x,alt.min=0,alt.max=Inf){
  stopifnot(inherits(x,"VPTimeSeries"))
  stopifnot(is.numeric(alt.min) & is.numeric(alt.max))
  interval=x$attributes$where$interval
  index=which(x$heights>alt.min & x$heights<alt.max)
  mtr=colSums(x$data$ff[index,]*x$data$dens[index,],na.rm=T)*interval/1000
  output=data.frame(dates=x$dates,mtr=mtr)
  rownames(output)=NULL
  return(output)
}

#' Class VP: vertical profile
#'
#' Class for vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VP=function(x) print.VP(x)

#' @rdname summary.VP
#' @export
#' @return for \code{is.VP}: \code{TRUE} if its argument is of class "\code{VP}"
is.VP <- function(x) inherits(x, "VP")

#' @rdname summary.VP
#' @export
#' @return for \code{dim.VP}: dimensions of the profile data
dim.VP <- function(x) {
  stopifnot(inherits(x,"VP"))
  dim(x$data)
}

#' Class VPList: list of vertical profiles
#'
#' Class for list of vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VPList=function(x) print.VPList(x)

#' @rdname summary.VPList
#' @export
#' @return for \code{is.VPList}: \code{TRUE} if its argument is of class "\code{VPList}"
is.VPList <- function(x) inherits(x, "VPList")


#' Class VPTimeSeries: time series of vertical profiles
#'
#' Class for single-site time series of vertical profiles
#' @param x object
#' @export
#' @details
#' details to be written
summary.VPTimeSeries=function(x) print.VPTimeSeries(x)


#' @rdname summary.VPTimeSeries
#' @export
#' @return for \code{is.VPTimeSeries}: \code{TRUE} if its argument is of class "\code{VPTimeSeries}"
is.VPTimeSeries <- function(x) inherits(x, "VPTimeSeries")

#' @rdname summary.VPTimeSeries
#' @export
#' @return for \code{dim.VPTimeSeries}: dimensions of the time series
dim.VPTimeSeries <- function(x) {
  stopifnot(inherits(x,"VPTimeSeries"))
  data.dim=dim(x$data[[1]])
  c(data.dim,length(x$data))
}

#' @rdname summary.VPList
#' @export
#' @keywords internal
`[.VPTimeSeries` <- function(x,i) {
  stopifnot(inherits(x,"VPTimeSeries"))
  if(length(i)<2) stop("Time series should consist more than one profile")
  x$dates=x$dates[i]
  x$daterange=.POSIXct(c(min(x$dates),max(x$dates)),tz="UTC")
  x$timesteps=difftime(x$dates[-1],x$dates[-length(x$dates)],units="secs")
  if(length(unique(x$timesteps))==1) x$regular = T else x$regular = F
  quantity.names=names(x$data)
  x$data=lapply(names(x$data),function(quantity) getElement(x$data,quantity)[,i])
  names(x$data)=quantity.names
  return(x)
}

#' Radar cross section
#'
#' Gives the currently assumedradar cross section in cm^2.
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @export
#' @return a radar cross section in cm^2
#' @examples
#' # extract RCS for a single vertical profile:
#' rcs(VP)
rcs <- function (x, ...) UseMethod("rcs", x)

#' @describeIn rcs radar cross section of a vertical profile
#' @method rcs VP
#' @export
rcs.VP <- function (x){
  stopifnot(inherits(x,"VP"))
  x$attributes$how$rcs_bird
}

#' @describeIn rcs radar cross section of a vertical profile
#' @method rcs VPList
#' @export
rcs.VPList <- function (x){
  stopifnot(inherits(x,"VPList"))
  output=sapply(x,`rcs.VP`)
  output
}

#' @describeIn rcs radar cross section of a vertical profile
#' @method rcs VPTimeSeries
#' @export
rcs.VPTimeSeries <- function (x){
  stopifnot(inherits(x,"VPTimeSeries"))
  x$attributes$how$rcs_bird
}

#' Set radar cross section
#'
#' Sets the assumed radar cross section in cm^2. This method also updates the migration densities in \code{x$data$dens}
#' @param x a \code{VP}, \code{VPList} or \code{VPTimeSeries} object
#' @export
#' @examples
#' # change RCS for a single vertical profile:
#' rcs(VP)<-20
`rcs<-` <- function (x, ...) UseMethod("rcs<-", x)

#' @rdname rcs-set
#' @method rcs<- VP

#' @export
`rcs<-.VP` <- function(x,value){
  stopifnot(inherits(x,"VP"))
  x$attributes$how$rcs_bird=value
  x$data$dens=x$data$eta/value
  x
}

#' @rdname rcs-set
#' @method rcs<- VPList
#' @export
`rcs<-.VPList` <- function(x,value){
  stopifnot(inherits(x,"VPList"))
  output=lapply(x,`rcs<-.VP`,value=value)
  class(output)="VPList"
  output
}

#' @rdname rcs-set
#' @method rcs<- VPTimeSeries
#' @export
`rcs<-.VPTimeSeries` <- function(x,value){
  stopifnot(inherits(x,"VPTimeSeries"))
  x$attributes$how$rcs_bird=value
  x$data$dens=x$data$eta/value
  x
}

#' Migration traffic
#'
#' Total migration traffic, which is calculated by time-integration
#' of migration traffic rates. Migration traffic gives the number of individuals
#' that have passed per km perpendicular to the migratory direction at the
#' position of the radar for the full period of the time series
#' within the specified altitude band.
#' @param x an object inhereting from class '\code{VPTimeSeries}'
#' @inheritParams mtr
#' @export
#' @return a numeric value equal to migration traffic in number of individuals / km
mt <- function(x,alt.min=0, alt.max=Inf){
  stopifnot(inherits(x,"VPTimeSeries"))
  dt=(c(0,x$timesteps)+c(x$timesteps,0))/2
  # convert to hours
  dt=dt/3600
  sum(dt*mtr(x,alt.min,alt.max)$mtr)
}

#' Cumulative migration traffic
#'
#' Cumulative migration traffic is calculated as the cumulative sum of
#' of the migration traffic within each time step of a time series.
#' Cumulative migration traffic gives the number of individuals
#' that have passed per km perpendicular to the migratory direction at the
#' position of the radar as a function time from the start of time series
#' within the specified altitude band.
#' @inheritParams mtr
#' @export
#' @return a numeric value equal to migration traffic in number of individuals / km
#' @examples
#' # get the VPTS example dataset:
#' data(VPTS)
#' # print cumulative migration traffic to console:
#' cmt(VPTS)
#' # plot cumulative migration traffic:
#' plot(cmt(VPTS),type='l',xlab="time [UTC]",ylab="CMT [birds/km]")
cmt <- function(x,alt.min=0, alt.max=Inf){
  stopifnot(inherits(x,"VPTimeSeries"))
  dt=(c(0,x$timesteps)+c(x$timesteps,0))/2
  # convert to hours
  dt=dt/3600
  mtrs=mtr(x,alt.min,alt.max)
  data.frame(dates=mtrs$dates,cmt=cumsum(dt*mtrs$mtr))
}

# function obtained via Hidde Leijnse, source unknown
#' calculate sunrise and sunset
#' @param lon longitude in decimal degrees
#' @param lat latitude in decimal degrees
#' @param date date inhereting from class "\code{POSIXt}" or a string interpretable by \link[base]{as.Date}
#' @param elev sun elevation in degrees
#' @param rise whether to output for rising or setting sun
#' @export
#' @return the moment of sunrise or sunset in UTC time
#' @details The angular diameter of the sun is about 0.536 degrees, therefore the moment
#' of sunrise/sunset corresponds to half that elevation at -0.268 degrees.
#'
#' Note that for a given date and location, sunrise time can be after sunset time when
#' the moments of sunset and sunrise are not on the same day within the UTC time zone.
#'
#' Approximate astronomical formula are used, therefore the moment of sunrise / sunset may
#' be off by a few minutes
#' @examples
#' # sunrise in the Netherlands
#' suntime(5,53,"2016-01-01")
#' # sunset in the Netherlands
#' suntime(5,53,"2016-01-01",rise=F)
#' # civil twilight in Ithaca, NY, today
#' suntime(-76.5,42.4,Sys.time(),elev=-6)
suntime = function(lon, lat, date, elev=-0.268, rise = TRUE)
{
  dateOnly=as.Date(date)
  #Convert date to julian day
  yyyy = as.numeric(format(dateOnly,"%Y"))
  mm = as.numeric(format(dateOnly,"%m"))
  dd = as.numeric(format(dateOnly,"%d"))
  jy=yyyy

  if (any(jy == 0)) stop("get_time_sun: there is no year zero!")
  jy[jy < 0] = jy[jy < 0] + 1
  jm = mm
  jm[mm > 2] = mm[mm > 2] + 1
  jy[mm <= 2] = jy[mm <= 2] - 1
  jm[mm <= 2] = mm[mm <= 2] + 13
  julday = floor(365.25 * jy) + floor(30.6001 * jm) + dd + 1720995
  julday[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))] = julday[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))] + 2 - floor(0.01 * jy[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))]) + floor(0.25 * floor(0.01 * jy[(dd + 31 * (mm + 12 * yyyy)) >= (15 + 31 * (10 + 12 * 1582))]))
  julday0 = 2451545	#Julian day for 20000101

  #Calculation of eclips coordinates
  MeanLon = 280.460 + 0.9856474 * (julday - julday0)
  MeanAnom = 357.528 + 0.9856003 * (julday - julday0)
  EclipLon = MeanLon + 1.915 * sin(MeanAnom * pi / 180) + 0.020 * sin(2 * MeanAnom * pi / 180)
  EclipLon = EclipLon * pi / 180
  Obliquity = 23.439 - 0.0000004 * (julday - julday0)
  Obliquity = Obliquity * pi / 180

  #Calculation of the celestial coordinates of the sun
  RightAsc = atan2(cos(Obliquity) * sin(EclipLon), cos(EclipLon))
  Declinat = asin(sin(Obliquity) * sin(EclipLon))

  #Calculation of current, local hour angle
  acos_arg = (sin(elev * pi / 180) - sin(Declinat) * sin(lat * pi / 180)) / (cos(Declinat) * cos(lat * pi / 180))
  angleH = seq(1, 1, length.out = length(acos_arg)) * NA
  angleH[abs(acos_arg) <= 1] = acos(acos_arg[abs(acos_arg) <= 1])

  #Determine sign of the derivative to see if the sun is rising or setting
  if (rise) sign_angle = 1
  else sign_angle = -1
  sign_angle = -1 * sign_angle * sign(cos(Declinat) * cos(lat * pi / 180) * sin(angleH))
  sign_angle[sign_angle == 0] = 1

  #Determine time
  GMST = (sign_angle * angleH - lon * pi / 180 + RightAsc) / 15
  hour = GMST * 180 / pi - 6.697375 - 0.0657098242 * (julday - julday0)
  hour = hour - floor(hour / 24) * 24

  output=as.POSIXct(as.POSIXlt(dateOnly,tz='UTC'))+3600*hour
  return(output)
}
